<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux 常用命令]]></title>
    <url>%2F2018%2F07%2F16%2Flinux-command%2F</url>
    <content type="text"><![CDATA[Linux路径linux绝对路径以”/“开头显示当前文件列表ll或ls复制文件如果dir2目录不存在，则可以直接使用cp -r dir1 dir2 即可。如果dir2目录已存在，则需要使用cp -r dir1/. dir2统计某文件夹下文件的个数ls -l |grep “^-“|wc -l统计某文件夹下目录的个数ls -l |grep “^ｄ”|wc -l统计文件夹下文件的个数，包括子文件夹里的ls -lR|grep “^-“|wc -l查看文件夹下文件大小du -sh *文件重命名mv abc.txt 1234.txt文件删除find lib -type f -name “*.0” -exec rm -f {} \; 查找末尾.0的文件删除rm -f 强制删除文件rm -rf 向下递归删除文件夹打开文件cat [-n] 文件名 -n代表显示行号设置权限chmod -R 755 文件名运行jar和停止jarjava -jar jar包 运行jar包 当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序 退出java -jar jar包 &amp; &amp;代表在后台运行。特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。nohup java -jar jar包 &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。nohup java -jar jar包 &gt;temp.txt &amp; command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。jobs 查看后台运行任务fg 任务号 调到前台ps aux|grep jar包 查看jar包进程kill -9 查到的进程 停止jar运行查看系统资源占用free －b －s5 每5秒刷新 查看内存top -c 每5秒刷新df 查看磁盘空间glances 查看系统工具查看日志linux查看日志文件内容命令tail、cat、tac、head、echotail -f test.log你会看到屏幕不断有内容被打印出来. 这时候中断第一个进程Ctrl-C,linux 如何显示一个文件的某几行(中间几行)从第3000行开始，显示1000行。即显示3000~3999行cat filename | tail -n +3000 | head -n 1000显示1000行到3000行cat filename| head -n 3000 | tail -n +1000*注意两种方法的顺序分解：tail -n 1000：显示最后1000行tail -n +1000：从1000行开始显示，显示1000行以后的head -n 1000：显示前面1000行用sed命令sed -n ‘5,10p’ filename 这样你就可以只查看文件的第5行到第10行。例：cat mylog.log | tail -n 1000 #输出mylog.log 文件最后一千行cat主要有三大功能：1.一次显示整个文件。$ cat filename2.从键盘创建一个文件。$ cat &gt; filename只能创建新文件,不能编辑已有文件.3.将几个文件合并为一个文件： $cat file1 file2 &gt; file参数：-n 或 –number 由 1 开始对所有输出的行数编号-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行-v 或 –show-nonprinting例：把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里cat -n textfile1 &gt; textfile2把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。cat -b textfile1 textfile2 &gt;&gt; textfile3把test.txt文件扔进垃圾箱，赋空值test.txtcat /dev/null &gt; /etc/test.txt注意：&gt;意思是创建，&gt;&gt;是追加。千万不要弄混了。tac (反向列示)tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！在Linux中echo命令用来在标准输出上显示一段字符，比如：echo “the echo command test!”这个就会输出“the echo command test!”这一行文字！echo “the echo command test!”&gt;a.sh这个就会在a.sh文件中输出“the echo command test!”这一行文字！该命令的一般格式为： echo [ -n ] 字符串其中选项n表示输出文字后不换行；字符串能加引号，也能不加引号。用echo命令输出加引号的字符串时，将字符串原样输出；用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。退出命令qctrl cXShell5工具上传文件到linux-b 以二进制方式，默认为文本方式。-e 对所有控制字符转义。如果要保证上传的文件内容在服务器端保存之后与原始文件一致，最好同时设置这两个标志，如下所示方式使用：rz –bey下载一个文件sz filename下载多个文件sz filename1 filename2下载dir目录下的文件，不包括文件夹sz dir/*]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常处理]]></title>
    <url>%2F2018%2F07%2F06%2Fjava-throwable%2F</url>
    <content type="text"><![CDATA[Java异常类层次结构图什么是异常异常的英文单词是exception，字面翻译就是“意外、例外”的意思，也就是非正常情况。事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，通过异常机制来处理程序运行期间出现的错误。通过异常机制，我们可以更好地提升程序的健壮性。unchecked exception（非检查异常）也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。checked exception（检查异常，编译异常）也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。Throwable有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。Error（错误）是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。Exception（异常）是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。区别注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。应该catch什么其实只要是Throwable和其子类都是可以throw和catch的，那么如果在需要统一处理异常的地方，我们应该catch (Throwable th) 还是 catch (Exception)呢？这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。先不考虑有其他的类继承了Throwable的情况下，第一种catch相当于比第二种catch多捕捉了把Error和其子类。那么究竟Error是否需要捕捉呢？JDK中Error类的的注释（如下）里提到过，Error是一种严重的问题，应用程序不应该捕捉它。An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a “normal” condition, is also a subclass of Error because most applications should not try to catch it.A method is not required to declare in its throws clause any subclasses of Error that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur.Java Lanuage Spec 7 中也提到：Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)“来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。The class Error is a separate subclass ofThrowable, distinct from Exception in the classhierarchy, to allow programs to use the idiom “} catch (Exception e) { ” (§11.2.3)to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible.已经不难看出，Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用。Error可以catch吗？ 可以catch了后做些其他处理吗？Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
        <tag>throwable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Mac 环境配置]]></title>
    <url>%2F2018%2F07%2F04%2Fandroid-mac%2F</url>
    <content type="text"><![CDATA[Java环境1）下载安装mac系统一般默认会安装jdk 1.6,路径为/System/Library/Java/JavaVirtualMachines/1.6.0.jdk,但有时候可能需要下载更高版本的jdk官网下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html2）配置配置方式为 vim ~/.bash_profile,增加或修改export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Homeexport JAVA_HOMEexport PATH=$PATH:$JAVA_HOME最后重新加载profilesource ~/.bash_profile3）验证java -version可以查看到当前版本信息代表安装配置成功。Android Studio1） 下载安装官网下载：http://developer.android.com/tools/studio/index.html得到的dmg文件直接拖到Applications安装，注意安装路径]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冷月当空，雪魂飞舞]]></title>
    <url>%2F2018%2F07%2F04%2Fhello-world%2F</url>
    <content type="text"><![CDATA[欢迎来到冷月阁简介这是一个小小的博客进行必要的知识储备，现如今是信息时代，知识更新迅速，需要不断学习，才能保证不被时代丢弃，我是一个程序员，所以这里会是我各种技术文档的存放地，当然也可能会存放其他文章，视情况而定，所以出现其他类文章，大家不要惊讶，哈哈。]]></content>
  </entry>
</search>
