<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷月阁</title>
  
  <subtitle>知识库</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rexlinbin.github.io/"/>
  <updated>2018-08-30T02:49:29.295Z</updated>
  <id>https://rexlinbin.github.io/</id>
  
  <author>
    <name>冷月灬雪魂</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Kotlin介绍</title>
    <link href="https://rexlinbin.github.io/2018/08/30/android-kotlin/"/>
    <id>https://rexlinbin.github.io/2018/08/30/android-kotlin/</id>
    <published>2018-08-30T01:55:21.000Z</published>
    <updated>2018-08-30T02:49:29.295Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><p>#Java的辉煌与阴影<br>说到Android，就不能不谈谈Android的开发语言java。</p><p>##Java的辉煌<br>1995年，当年如日中天的Sun公司发布了Java语言，引起了巨大的轰动，与当时主流的C语言和Basic语言比起来，Java语言简单、面向对象、稳定、与平台无关、解释型、多线程、动态等特点，就像是打开了一个新的世界，一时间风靡全球，云集者众，微软为了模仿Java搞出C#语言，Netscape为了赶时髦硬塞出一个JavaScript语言，IBM则捏着鼻子做了Java IDE Eclipse（日蚀，呵呵）。直到现在，Java在编程世界里还占据着举足轻重的地位，Andy Rubin在开发Android系统时，也很自然地采用了Java和C++（C++负责NDK开发）作为开发语言。<br><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=241998499,3490674482&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=681&amp;s=4CA63472911FD1CE0EFD94CA0000E0B2" alt=""></p><p>##Java的阴影<br>Java毕竟是20多年前的语言了，虽然有不断扩展更新，但是底层设计思想是很难改动的，这就导致它很难实现一些新的语言特性，例如函数式编程、流式API、高阶函数、空指针安全等，这些新的语言特性大受好评，可以说解放了编程的生产力，这其实也说明了一个事实：开发效率/时间是软件公司真正的瓶颈，任何能压缩代码量，提高开发效率的举措，都应该受到重视。</p><p>而且，Android还存在Java版权危机的问题，收购了Sun公司的Oracle曾向Google索要巨额的Java版权费，这可能也加快了Google寻找Android开发替代语言的动作。</p><p>苹果公司已经在用Swift语言替代Object-C语言，Google也找到了替代Java的语言，也就是JetBrains公司（Android Studio也是用该公司的Intelli J改的）主推的Kotlin，Kotlin 有着“Android世界的Swift”的称号。</p><p>#Kotlin简介<br><img src="https://files.jb51.net/file_images/article/201706/201706200944528.jpg" alt=""><br>Kotlin是一门编程语言，由JetBrains公司开发的，早在2010年就推出Kotlin了。JetBrains就是那个开发了无数个牛逼IDE的公司，Android Studio就是建立在他家的Intellij之上的。而在2017年5月18日，谷歌在今日举行的I/O开发者大会上宣布，将Kotlin语言作为安卓开发的一级编程语言。</p><p>Kotlin是基于JVM的，可于Java进行无缝混编，所以开发者可以十分方便地用它来进行Android开发。下图为Android开发使用Kotlin的占比：<br><img src="http://t11.baidu.com/it/u=1587471088,2587157150&amp;fm=173&amp;app=25&amp;f=JPG?w=640&amp;h=407&amp;s=48A23D720166790B5D44C5C20300F0B7" alt=""></p><p>#Kotlin的特性</p><p>##空指针安全<br>空指针异常的确是困扰Java程序员很多年的问题，Swift语言巧妙地解决了这个问题，Kotlin采用了一样的解决方案，只是语法形式不太一样。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> room: Room? = ...</span><br><span class="line">room?.window?.<span class="keyword">open</span>()</span><br></pre></td></tr></table></figure><p>##函数方法<br>在Kotlin语言中，类终于不再是一等公民。Kotlin语言开始支持面向过程编程，Kotlin语言中可以声明全局函数，内联函数等，还支持函数嵌套，使用函数作为方法参数等操作。对于一些简单的操作，新建一个类去处理，的确有时候是一个让人头疼的问题，Kotlin语言终于让我们摆脱了这一尴尬的现状。</p><p>函数的写法有较大的不同，Kotlin语法类似Swift语言的写法，每个函数都必须使用fun关键字声明，参数类型在后，参数名称在前，对于Java语言开发的同学可以需要一个短暂的适应过程。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String <span class="title">sayHello</span><span class="params">(name: <span class="type">String</span>?)</span></span>: String &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"Hello, <span class="variable">$name</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##类扩展<br>Kotlin语言支持对现有的类进行扩展。Java程序员应该会对这个特性比较陌生，这也是Swift语言的一个特性之一。所谓扩展，就是在不使用继承的情况下，对现有的类新增方法，属性等操作，扩展不会破坏现有的类方法，仅仅在使用的时候进行动态添加。应该记住一个原则： 扩展优于继承。而这个特性Java语言并不支持。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">format</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.replace(<span class="string">' '</span>, <span class="string">'_'</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> formatted = str.format()</span><br></pre></td></tr></table></figure><p></p><p>##数据类<br>在开发过程中，我们常常要不断写一些Model类，不断地使用开发工具生成set/get方法。Data Class就是为简化这个操作而生的，数据类会自动生成set/get方法，而不用显式生成set/get方法。<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String,</span><br><span class="line">                  <span class="keyword">var</span> email: String,</span><br><span class="line">                  <span class="keyword">var</span> age: <span class="built_in">Int</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> john = Person(<span class="string">"John"</span>, <span class="string">"john@gmail.com"</span>, <span class="number">112</span>)</span><br></pre></td></tr></table></figure><p></p><p>##高阶函数<br>所谓的高阶函数就是</p><ul><li>可以接受函数作为参数</li><li>也可以返回函数作为结果。<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">lock</span><span class="params">(lock: <span class="type">Lock</span>, body: ()</span></span> -&gt; T): T &#123;</span><br><span class="line">  lock.lock()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> body()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>##与java的交互性好<br>Kotlin和Java都属于基于JVM的编程语言。Kotlin和Java的交互性很好，可以说是无缝连接。这表现在</p><ul><li>Kotlin可以自由的引用Java的代码，反之亦然。</li><li>Kotlin可以使用现有的全部的Java框架和库</li><li>Java文件可以很轻松的借助IntelliJ的插件转成kotlin</li></ul><p>#Kotlin的现状<br>随着技术的逐渐深入，不少开发者也发出从 Java 到 Kotlin，再到 Java 的无奈感叹，那么 Kotlin 现状究竟如何？</p><p>对此，国外一家名为 Pusher 的公司在今年 1 月至 3 月期间基于 Kotlin 对世界范围内的 2744 名 IT 人员进行了深入地调查，并于昨日正式发布了《The State of Kotlin 2018》报告，分享了如今 Kotlin 的使用情况，以及生态系统的发展趋势。<br><img src="http://t10.baidu.com/it/u=2558593449,3789414354&amp;fm=173&amp;app=25&amp;f=JPG?w=639&amp;h=335&amp;s=60F3236223F08FD80CE26A8F0300508F" alt=""></p><p>##年轻的开发者更钟爱 Kotlin</p><p>超过一半的受访者表示其作为开发人员工作的时间不到 5 年，2-5 年工作经验的占 33.9%，1-2 年的占 15.2%。本报告受访者的工作经验比参加 StackOverflow 调查的开发者要少一些。然而，“开发者数量每 5 年翻一番”的传统理念依旧存在，未来 Kotlin 的开发者只会越来越多。</p><p><img src="http://t12.baidu.com/it/u=3815277833,3337700122&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=470&amp;s=26B2572216E7814D1CD7038A0200E08E" alt=""></p><p>##Kotlin 使用率迅猛增长，但不是开发者的首选语言</p><p>Kotlin 的增长率每年都在翻倍，到了 2015 年，其使用量首次出现大幅飙升，从上一年的 1.4% 激增到 7.7%。对于增长的原因，想必和同年间 Android 大神 Jake Wharton 发布的文档（<a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8）有关，该文档旨在主张使用" target="_blank" rel="noopener">https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8）有关，该文档旨在主张使用</a> Kotlin 进行开发，并创建了一些流行的 Android 开源库。这就导致了很多的 Android 开发者效仿，并使用了 Kotlin 开始创建项目。</p><p><img src="http://t11.baidu.com/it/u=1587471088,2587157150&amp;fm=173&amp;app=25&amp;f=JPG?w=640&amp;h=407&amp;s=48A23D720166790B5D44C5C20300F0B7" alt=""></p><p>而 2017 年 5 月，Google 宣布 Kotlin 正式支持 Android，由此看出，大量 Android 开发者开始使用 Kotlin，占比达到了 46.8%。这其中不乏有因 Google 品牌吸引而投身于 Kotlin 开发的学生，据调查显示，早期，Kotlin 主要由经验丰富的专业开发者使用，如今大批年轻的开发者及学生开始涌入。</p><p><img src="http://t12.baidu.com/it/u=3080312582,890753404&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=512&amp;s=0CA67C324B767D8E5E44C5C20200B0B7" alt=""></p><p>不过，目前 Java 仍占主要地位，同时也有很多开发者使用其他的编程语言，诸如 JavaScript、Python、Swift、C# 等等，因此大多数的开发者并没有将 Kotlin 作为其第一编程语言。</p><p><img src="http://t11.baidu.com/it/u=631642687,2129493060&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=542&amp;s=26B3C32257F7B67A4ED253870200E08C" alt=""></p><p>##Kotlin 更多的是用于个人项目，而非企业项目</p><p>受访者中，有超过 60％ 的开发者正在工作项目中使用 Kotlin。相比之下，有三分之一的受访学生将其用于工作和辅助项目。 也就是说，他们中有近一半的人表示打算在未来开始使用它。</p><p><img src="http://t12.baidu.com/it/u=353887511,455156876&amp;fm=173&amp;app=25&amp;f=JPG?w=640&amp;h=552&amp;s=4E885A224C38F688DA495FDC020080A4" alt=""></p><p>Kotlin 更多的是被用于私人项目，而非工作项目中。</p><p><img src="http://t12.baidu.com/it/u=2197093817,982826030&amp;fm=173&amp;app=25&amp;f=JPEG?w=639&amp;h=419&amp;s=3ECA56220194A5CACCF28E820200A08F" alt=""></p><p>##最爱的特性</p><p>对于每位 Android 开发者来说，只要使用过 Java 的 NullPointerException 的特性都会喜欢上 Kotlin 的安全性能，其次分别是扩展函数、Java 的互操作性。有 77％ 的受访者表示，Kotlin 扩展功能往往使代码更具可读性，尤其是在函数编程环境中或创建 DSL 时。</p><p><img src="http://t11.baidu.com/it/u=2142724024,3004136994&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=424&amp;s=FD8A5D32CCF65E8AB30F16D60200D0A4" alt=""></p><p>跨平台 Kotlin 正在复苏，但速度较为缓慢。只有约四分之一的受访者提到他们运用了一些跨平台支持，大多数选择 Kotlin / Native，其次是 KotlinJS。</p><p><img src="http://t10.baidu.com/it/u=4268077491,2245823478&amp;fm=173&amp;app=25&amp;f=JPEG?w=640&amp;h=535&amp;s=64B18272DA1246DC109B3E9D0200808C" alt=""></p><p>#Kotlin的未来</p><p>Kotlin 整体的发展速度还是让不少开发者为之兴奋。同时鉴于 JetBrains 和Google 的大力支持，以及开发者社区的热捧，我们也相信它会越来越流行。但如今主要的问题是，它在未来是否会成功地入主 Android 以外的应用？</p><p>如今 JetBrains 正在大肆推动 Kotlin 的多平台应用，它是否会得到大家的认可也仍未可知。但是想要它成为 Web、iOS 以及后端开发者新的标准，想必也还需要数年的时间来扩展。根据调查报告显示，越多越多的开发者迈出了 Kotlin 编程的第一步，也可以在面向对象、函数、脚本之间穿梭。这就足以说明，Kotlin 正在渗入到整个开发的生态系统中。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;p&gt;#Java的辉煌与阴影&lt;br&gt;说到Android，就不能不谈谈Android的开发语言java。&lt;/p&gt;&lt;p&gt;##Java的辉煌&lt;br&gt;1995年，当年如日
      
    
    </summary>
    
      <category term="android" scheme="https://rexlinbin.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://rexlinbin.github.io/tags/android/"/>
    
      <category term="kotlin" scheme="https://rexlinbin.github.io/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>商业云服务平台正在成为黑客对用户下手的渠道</title>
    <link href="https://rexlinbin.github.io/2018/08/28/amazon/"/>
    <id>https://rexlinbin.github.io/2018/08/28/amazon/</id>
    <published>2018-08-28T07:27:51.000Z</published>
    <updated>2018-08-28T07:50:43.374Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><p>##前言</p><p><font color="#00dd00">来自国外的Threat Stack网络安全团队的研究人员表示黑客利用正在利用商业云服务平台的特性对目标用户发起恶意活动，并隐藏自己的行踪。</font><br><img src="http://image.3001.net/images/20180823/15350039762754.png!small" alt=""></p><p>越来越多的证据表明，黑客正在将目光对准云服务用户，利用公共云平台常见的功能来隐藏活动以长驻目标网络进行恶意活动。</p><p>来自Threat Stack网络安全团队数年来一直在跟踪和观看黑客利用云服务的模式。一个明显的分水岭是2016年，他们注意到利用亚马逊网络服务（AWS）进行攻击的复杂性陡然上升。在2017年这种趋势更加明显。该团队指出，问题不在于AWS服务和软件存在漏洞，而在于黑客能够以巧妙的方式利用它的特性。</p><p>举个简单的例子：</p><blockquote><p>黑客通常可以通过窃取AWS密钥来获得存储在开放S3容器中的资源路径，或者启动新的Amazon Elastic Compute Cloud（EC2）来挖矿。这种情况已经很常见了，在过去的几年里配置错误的S3容器好几次都登上了头条新闻。亚马逊强调默认情况下S3容器是安全的;，还推出了Macie以保护AWS S3数据，并通过Trusted Advisor提供免费的容器检查。</p></blockquote><p>针对亚马逊推出的一系列安全服务，黑客这边也没有闲着。利用AWS进行恶意活动变得越来越复杂，针对性越来越强，可与基于网络的入侵攻击相结合。</p><p>##工作原理<br>大多数这些攻击都始于凭证被窃取，黑客通过网络钓鱼窃取访问密钥或凭据，部署恶意软件以获取用户名和密码，或者是其他感兴趣的信息。</p><p>在获取凭证之后，下一步是确定可以获得的权限级别。如果没有黑客想要的东西，他可能会尝试在AWS中创建其他账户或凭据，然后在目标环境中启动新的EC2实例。</p><p>此时，黑客可在网络中调用EC2实例来扫描主机。登陆新主机后，黑客会检查其AWS权限。如果只是在寻找少量数据，那么在受感染的终端或主机上绕过DLP工具即可。具体怎么做取决于黑客的动机。</p><p>##行为模式<br>这种情况通常出现在针对性的持续攻击中，黑客试图获得对特定数据的访问权限，包括制造业、金融业和高科技行业等都是他们的热门目标。</p><p>如何获取数据和数据量多大还是取决于目的。举个例子，如果公司存储医疗保健信息或选民记录，则黑客可能会批量查找数据。而黑客瞄准媒体公司的话，可能只想要知道即将发布的产品信息或更具体的内容，这样只要复制和粘贴或截取屏幕截图即可，这种方式更难察觉到。</p><p>##总结<br>在AWS场景中，横向攻击难以被检测到的一个原因是，大多数安全监控技术都假设攻击者潜入主机并升级权限。而在这种情况下，黑客会尽量离开主机层返回到AWS控制平面，大多数安全人员可能都不会注意到这种操作。</p><p>来自FreeBuf.COM</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;p&gt;##前言&lt;/p&gt;&lt;p&gt;&lt;font color=&quot;#00dd00&quot;&gt;来自国外的Threat Stack网络安全团队的研究人员表示黑客利用正在利用商业云服务平台
      
    
    </summary>
    
      <category term="产品" scheme="https://rexlinbin.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="云服务" scheme="https://rexlinbin.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="资料" scheme="https://rexlinbin.github.io/tags/%E8%B5%84%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title>Ridrelay：一款用于在内网中快速查找域用户名的工具</title>
    <link href="https://rexlinbin.github.io/2018/08/20/ridrelay/"/>
    <id>https://rexlinbin.github.io/2018/08/20/ridrelay/</id>
    <published>2018-08-20T02:55:51.000Z</published>
    <updated>2018-08-20T02:55:59.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><p>今天给大家介绍一款名叫Ridrelay的工具，研究人员可以在只有低等级权限的情况下，利用该工具枚举出内部网络中的域用户名信息。<br><img src="http://image.3001.net/images/20180814/1534221560_5b725cf822e43.png!small" alt=""></p><p>##RidRelay运行机制<br>RidRelay整合了SMB Relay攻击技术，常见的基于lsarpc查询和RID循环来获取域用户名列表，其工作步骤如下：</p><blockquote><ol><li>启动一台SMB服务器并等待传入的SMB连接；</li><li>传入的凭证数据会被中继传输到指定的目标，并创建中继用户的上下文连接；</li><li>查询请求会传输到SMB连接的lasrpc管道，并获取域用户名信息（通过50000次RID循环实现）；</li></ol></blockquote><p>##依赖组件</p><blockquote><p>Python2.7<br>Impacketv0.9.17（或更新版本）</p></blockquote><p>##工具安装<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pipenv install --two</span><br><span class="line">pipenv shell</span><br><span class="line"> </span><br><span class="line">#Optional: Run if installing impacket</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">cd submodules/impacket</span><br><span class="line">python setup.py install</span><br><span class="line">cd ../..</span><br></pre></td></tr></table></figure><p></p><p>##工具使用<br>首先，找到需要建立中继连接的目标主机，目标主机必须是域成员，而且必须支持SMB，这一步操作可以使用CrackMapExec来实现。</p><p>运行RidRelay，并指向目标主机：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ridrelay.py -t 10.0.0.50</span><br></pre></td></tr></table></figure><p></p><p>或者直接将用户名信息输出到文件中：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ridrelay.py -t 10.0.0.50 -o path_to_output.txt</span><br></pre></td></tr></table></figure><p></p><p>强烈建议：使用Responder来欺骗目标用户连接RidRelay。</p><p>##新版本将添加的功能</p><blockquote><ol><li>添加密码策略枚举功能；</li><li>寻找拥有管理员权限的凭证，实现动态中继；</li><li>获取活跃会话连接；</li><li>整合BloodHound（一款强大的内网域渗透提权分析工具）</li></ol></blockquote><p>来自FreeBuf.COM</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;p&gt;今天给大家介绍一款名叫Ridrelay的工具，研究人员可以在只有低等级权限的情况下，利用该工具枚举出内部网络中的域用户名信息。&lt;br&gt;&lt;img src=&quot;h
      
    
    </summary>
    
      <category term="工具" scheme="https://rexlinbin.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://rexlinbin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>看Hidden Bee如何利用新型漏洞进行传播</title>
    <link href="https://rexlinbin.github.io/2018/08/20/hidden-bee/"/>
    <id>https://rexlinbin.github.io/2018/08/20/hidden-bee/</id>
    <published>2018-08-20T02:55:51.000Z</published>
    <updated>2018-08-20T02:59:15.044Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><p><img src="http://image.3001.net/images/20180803/1533268006_5b63d0260997f.jpg" alt=""></p><p>#写在前面的话</p><font color="#00dd00">最近我们发现了一个试图利用CVE-2018-4878（Flash Player中的漏洞）漏洞的攻击，其序列与我们当前发现的任何漏洞利用工具都不一样。经过调查，我们发现这是中国安全公司奇虎360在2017年年底所引用的现有开发框架的一部分。但当时payload似乎是一个推广广告软件的木马。而这次使用的payload它不是一个标准的PE文件。相反，它更像是一种多阶段可执行格式，并且它还充当一个下载加载程序，用于检索隐藏的Bee miner僵尸网络使用的LUA脚本。这可能是第一个用来挖掘加密货币的bootkit案例。</font><p>#广告概述<br>攻击者利用成人网站的诱惑性广告将受害者吸引到钓鱼页面。我们认为此系列广告主要针对亚洲国家地区用户，根据所投放的广告和我们已知的数据。这个声称是可以在线约会服务的服务器包含一个恶意的iframe，其主要负责开发和感染用户。</p><p><img src="http://image.3001.net/images/20180803/1533267594_5b63ce8a5fa20.png!small" alt=""></p><p><img src="http://image.3001.net/images/20180803/1533267607_5b63ce970789c.png!small" alt=""></p><p>#IE exploit<br>在这里，恶意代码从具有嵌入式加密块的网页开始执行。并采用Base64编码，然后使用RC4或Rabbit两种算法之一进行加密：<br><img src="http://image.3001.net/images/20180803/1533267672_5b63ced8b6d17.png!small" alt=""></p><p>在解密之后，该块将被执行。您可以在这里找到正在运行的Java Script的解码版本。我们可以在脚本中看到，它会生成随机会话密钥，然后使用攻击者的公共RSA密钥对其进行加密：<br><img src="http://image.3001.net/images/20180803/1533267682_5b63cee2894af.png!small" alt=""></p><p>加密的密钥将传递到下一个函数并转换为JSON格式，对硬编码的URL执行POST请求：<br><img src="http://image.3001.net/images/20180803/1533267694_5b63ceee575df.png!small" alt=""></p><p>如果我们查看客户端和服务器之间的流量（客户端发送加密的“key”，服务器响应“value”），我们更明显发现这一点：<br><img src="http://image.3001.net/images/20180803/1533267704_5b63cef8b0954.png!small" alt=""></p><p>#服务器端<br>1.攻击者的使用私有RSA密钥加密，服务器传递解密会话的密钥。</p><p>2.选择对称算法来(Rabbit或RC4)加密漏洞payload。</p><p>3.将加密的内容返回给客户端。由于客户端在内存中仍然有密钥的未加密版本，所以它能够解密并执行该漏洞。然而，只从通信流量不能检索原始会话密钥，也不可能重现漏洞。但幸运的是，我们在动态分析中成功捕获了漏洞。并且我们发现攻击者利用的漏洞是CVE-2018-8174。</p><p>#Flash漏洞利用<br>这是一个较新的Flash漏洞（CVE-2018-4878）利用程序,在奇虎360发布文档时并不是其exploit kits的一部分，可能是为了增强其性能后来添加的。该漏洞中嵌入的shell代码仅仅是下一阶段的下载程序。成功利用后，它将在以下URL检索其payload：<br><img src="http://image.3001.net/images/20180803/1533267714_5b63cf02ee000.png!small" alt=""></p><p>这个扩展名为.wasm文件，伪造成一个Web Assembler模块。但事实上，它是完全不同的东西。</p><p>正如你所看到的，它加载了用于解压缩cabinet文件的Cabinet.dll模块。在后面的部分中，我们看到了用于通过HTTP协议进行通信的API和字符串。我们还发现了对“dllhost.exe”和“bin/i386/core.sdb”的引用。<br><img src="http://image.3001.net/images/20180803/1533267729_5b63cf114211d.png!small" alt=""></p><p>我们很容易猜到这个模块将下载并利用dllhost.exe来运行。而另一个字符串Base64编码的内容为：</p><p><img src="http://image.3001.net/images/20180803/1533267737_5b63cf1948415.png!small" alt=""></p><p>将其解码后的内容展现了更多的网址：</p><pre><code>http://103.35.72.223/git/wiki.asp?id=530475f52527a9ae1813d529653e9501http://103.35.72.223/git/glfw.wasmhttp://103.35.72.223/rt/lsv3i06rrmcu491c3tv82uf228.wasm</code></pre><p>看看Fiddler捕获的流量，我们发现其模块确实在查询这些URL：<br><img src="http://image.3001.net/images/20180803/1533267744_5b63cf2040524.png!small" alt=""></p><p>请求来自dllhost.exe，这可能意味着上面的可执行文件已经被注入恶意代码。文件glfw.wasm与Web Assembly之间没有任何共同之处。事实上，它是一个Cabinet文件，包含内部路径下的打包内容：bin/i386/core.sdb。从内部看，我们发现了相同的自定义可执行格式，比如DLL名称：<br><img src="http://image.3001.net/images/20180803/1533267751_5b63cf2703db2.png!small" alt=""></p><p>然后另一个问题是参与者可能试图通过假装使用SLTP协议来检索实际payload来隐藏流量，这可以在从核心内部的Cabinet文件中提取的字符串core.sdb中发现这一点：</p><pre><code>INSTALL_SOURCE&amp;sid=%uINSTALL_SIDINSTALL_CIDsltp://setup.gohub[.]online:1108/setup.bin?id=128ntdll.dllZwQueryInformationProcessVolumeNumberSCSIDISKos=%d&amp;ar=%dkernel32.dllIsWow64ProcessRtlGetNtVersionNumbersx&amp;sz=sltp</code></pre><p>该主机名解析为67.198.208[.]110：</p><pre><code>Pinging setup.gohub.online [67.198.208.110] with 32 bytes of data:Reply from 67.198.208.110: bytes=32 time=76ms TTL=51</code></pre><p>来自沙盒计算机的加密TCP网络流量显示了如何检索二进制的payload：<br><img src="http://image.3001.net/images/20180803/1533267760_5b63cf3000cee.png!small" alt=""></p><p>这个矿机的独特之处在于，它通过使用bootkit实现持久性，如本文所述。受感染的主机将修改其主引导记录，以便在每次操作系统启动时启动矿机。</p><p>#简单payload的复杂攻击<br>这种攻击在许多方面上都很有意思，因为它在漏洞利用交付部分中使用了不同的技术以及不同的打包payload技术。因此我们认为它集中在少数几个亚洲国家，不仅如此，它还表明威胁行动者并没有完全放弃exploit kits，尽管在过去几年有明显的下降趋势。<br><img src="http://image.3001.net/images/20180803/1533267775_5b63cf3fb95fc.gif!small" alt=""></p><p>IOC<br>受污染的交友网站</p><p>144.202.87[.]106</p><p>exploit kits</p><p>103.35.72[.]223</p><p>52he3kf2g2rr6l5s1as2u0198k.wasm</p><p>087FD1F1932CDC1949B6BBBD56C7689636DD47043C2F0B6002C9AFB979D0C1DD</p><p>glfw.wasm</p><p>CCD77AC6FE0C49B4F71552274764CCDDCBA9994DF33CC1240174BCAB11B52313</p><p>Payload URL 和 IP</p><pre><code>setup.gohub[.]online:1108/setup.bin?id=12867.198.208[.]110</code></pre><p>Miner Proxy</p><p>133.130.101[.]254</p><p>转载自FreeBuf</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;img src=&quot;http://image.3001.net/images/20180803/1533268006_5b63d0260997f.jpg&quot; 
      
    
    </summary>
    
      <category term="技术" scheme="https://rexlinbin.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="技术" scheme="https://rexlinbin.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="漏洞" scheme="https://rexlinbin.github.io/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>全球人口不足一部剧点击量，刷量黑色产业链了解一下</title>
    <link href="https://rexlinbin.github.io/2018/08/19/numup/"/>
    <id>https://rexlinbin.github.io/2018/08/19/numup/</id>
    <published>2018-08-19T06:50:51.000Z</published>
    <updated>2018-08-20T03:29:45.797Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><p><font color="#00dd00">最近正火的剧算是《延禧攻略》中皇后娘娘可谓是吸粉无数，截至目前总播放量达56亿，均集播放量超1.3亿。回看之前的《孤芳不自赏》播放量突破160亿……如此看来“全球人口都不足一部剧的播放量”并非玩笑话，这些播放量究竟从何而来呢？</font><br><img src="http://image.3001.net/images/20180815/1534300077_5b738fadbb631.jpeg!small" alt=""></p><p>##全球人口不足一部剧的点击量？</p><p>最近在微博上关于“电视剧播放量”的话题引起了大家的关注，目前的电视剧和网剧不断涌现，播放量也是屡创新高，但是面对这动辄几百亿的数字，好像让全球活着的生物一起参与其中才能够实现……<br><img src="http://image.3001.net/images/20180815/1534300088_5b738fb8de11c.jpg!small" alt=""></p><p>查看这个评分，再看这160亿的播放量，emmmmmm<br><img src="http://image.3001.net/images/20180815/1534300101_5b738fc55fc18.png!small" alt=""><br><img src="http://image.3001.net/images/20180815/1534300137_5b738fe9650ab.jpg!small" alt=""></p><p>这不禁让我们增添一丝疑问……</p><p>####这几百亿的播放量究竟是如何计算出来的？<br>目前根据国内大部分视频网站计算方式来看，官方统计的视频播放量并不完全是正片的播放量，很多是加入花絮、预告片、剧照、影视原声、主角cut等相关视频的播放量一起统计而成。打个比方，你观看了20个预告片就贡献了20个播放量，同时自动跳转下一集就贡献2个播放量，异常暂停也就贡献了2个播放量。<br><img src="http://image.3001.net/images/20180815/1534300159_5b738fff9dea4.png!small" alt=""></p><p>这样一来，很多上百亿的播放量似乎可以理解了一点，但是背后的庞大的数字真的毫无掺水效果吗？</p><p>##条条大路通黑产</p><p>抱着怀疑的心态我们随手搜索了一下各个渠道，结果一看吓一跳，可谓是每条路都是通向（黑产）发家致富的路啊……</p><p>###一、QQ群<br><img src="http://image.3001.net/images/20180815/1534300178_5b73901268361.png!small" alt=""></p><p>混进群内就发现市场很透明嘛，价格也是“童叟无欺”了，并且业务范围覆盖了市面上主要的视频网站。<br><img src="http://image.3001.net/images/20180815/1534300205_5b73902d169cf.png!small" alt=""></p><p>但是不同平台仍然存在部分差距，这是因为不同平台对于的检测机制不同，攻破的难度自然也不同，刷播放量行业在初期经过打击后现在技术逐渐趋向成熟。</p><p>有些平台是根据IP来判断，这时需换一下IP，再进入其网站进行点击即可；有些平台是根据缓存来判断，只需清除下浏览器缓存即可；有些平台是根据当前不同用户的登录来判断，这就需要我们重复进入该网站，多次注册不同的马甲用户，再来操作；有些是根据当前浏览行为判断，即你只要打开目标网址就算一次点击，这样我们只需重复打开关闭该网址即可。<br><img src="http://image.3001.net/images/20180815/1534300288_5b73908013290.jpg!small" alt=""><br><img src="http://image.3001.net/images/20180815/1534300765_5b73925d3f95d.jpg!small" alt=""></p><p>另外，除了原理的不同，各视频平台对点击量、播放量的处理方法也是不同，所以需要根据各个平台制定不同的脚本软件，脚本会随着平台的统计更新而升级。</p><p>顺着我也勾搭了一下群管理员，了解了一下目前的行情，平均价格在1,000播放量/8元左右，量大还可往下谈。<br><img src="http://image.3001.net/images/20180815/1534300298_5b73908a9d20d.png!small" alt=""></p><p>###二、电商平台<br>在某宝上搜索“刷播放量”，此类产品也是很多了。<br><img src="http://image.3001.net/images/20180815/1534300371_5b7390d30ae1e.png!small" alt=""><br><img src="http://image.3001.net/images/20180815/1534300382_5b7390de115c2.jpg!small" alt=""></p><p>###三、自建平台<br>除了上述的常见渠道，黑产这次还“自建平台”……<br><img src="http://image.3001.net/images/20180815/1534300399_5b7390ef40898.png!small" alt=""></p><p>联系了一下该账号，发现他是前面qq群的管理员(黑产业务初成规模了)……经过一番交流，了解到目前主要的视频网站的对于异常播放量会有一定的监管机制。<br><img src="http://image.3001.net/images/20180815/1534300415_5b7390ff536e9.png!small" alt=""></p><p>在平台的检测下，常见的机刷播放量可能暂时使播放量冲上去，但是面对视频网站的“二次监控”，必定会出现“掉量”的情况。也就是如上图聊天记录中问到卖家的“是否会掉”，对此卖家暂时也无法给出保证。</p><p>###四、软件刷播放量<br>在查找相关信息的时候，发现市面上还有一些“刷量软件”。<br><img src="http://image.3001.net/images/20180815/1534300454_5b739126255e1.png!small" alt=""></p><p>这些“刷量软件”大多出现在非官方应用商店内，来源不明确。知乎上也有人对这种软件提出质疑，有人回应被黑产骗了，看来这黑产真的使套路连套路，防不胜防……<br><img src="http://image.3001.net/images/20180815/1534300468_5b739134ea274.png!small" alt=""></p><p>除了上述渠道，在微博、贴吧、豆瓣等社交平台上，此项黑产“事业”也是渗透其中……<br><img src="http://image.3001.net/images/20180815/1534300491_5b73914ba4c53.png!small" alt=""></p><p>##暴利前行、饭圈助攻<br>当我们聊到电视剧、网剧刷播放量的时候，就不得不提及“饭圈”这一神秘组织。为了爱豆，追星女孩男孩们可以彻夜打榜，也可以不远万里追寻光芒：</p><p>1.2014年10月10日，鹿晗发布微博：“我回家了。” 149分钟后，回帖数突破了一百万。鹿晗的一条微博曾经打破了吉尼斯世界纪录，回复数是 100,252,605 条（无敌是多么~多么寂寞 无敌是多么~多么空虚）。</p><p>2.9月21号是TFBOYS成员王俊凯的18岁生日，王俊凯粉丝再次给了他海陆空集体应援。 太空环游纪念应援（将王俊凯的照片看板从美国内华达州发射上太空）；为王俊凯承包核心商圈LED屏；承包了全国500家影院的5,000块LED屏幕；无数流动的车身广告……</p><p>这样庞大又坚实的力量本是一腔热血为了爱豆成绩，但是一旦为黑产所用，变成其暴利四驱车上重要的车轮。<br><img src="http://image.3001.net/images/20180815/1534300513_5b739161c070e.png!small" alt=""><br><img src="http://image.3001.net/images/20180815/1534300531_5b739173b51ef.png!small" alt=""></p><p>简单计算一下，如果一部剧有200亿播放量是刷的，借用10,000次/8元的市场价格，仅一部剧黑产的收入就高达千万元！而仅2017年仅网剧就超过600部，背后巨大暴利我们无法估量……<br><img src="http://image.3001.net/images/20180815/1534300547_5b73918331e68.png!small" alt=""></p><p>对于这些“刷播放量”的行为，主要伤害的还是影视业本身，部分剧组为了收视效果也会选择刷量，成本增加，也坏了整个行业的风气，用圈内人的话说“别人都刷你不刷不就有点傻了嘛”。</p><p>其次也会影响观众的审美。现在影视作品层出不穷，我们的选择性也就更多了，原本整体的观众审美和品味在逐步的培养起来，但是过度的将“烂片”营造成好片必定会形成“柠檬市场”效应，资金少的好片子反而活不下去了，一切都被所谓的“流量”替代。</p><p>当然在这种情况下，我们的视频网站也在尝试做出更多努力，去年爱奇艺以杭州某信息科技公司的“刷量”行为侵犯了其合法权益、构成不正当竞争为由向上海市徐汇区人民法院提起诉讼，请求法院判令被告立即停止侵权行为，并赔偿其经济损失500万元。<br><img src="http://image.3001.net/images/20180815/1534300613_5b7391c546862.jpeg!small" alt=""></p><p>相信未来在监管上，各个平台也会做出更多努力。作为“看客”的我们从自身做起，别给黑产可乘之机。电影电视原本是为平凡生活织造的一个个梦，在梦里黑产是否应当给我们留一丝宁静呢。</p><p>来自FreeBuf.COM</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;font color=&quot;#00dd00&quot;&gt;最近正火的剧算是《延禧攻略》中皇后娘娘可谓是吸粉无数，截至目前总播放量达56亿，均集播放量超1.3亿。回看之前的
      
    
    </summary>
    
      <category term="产品" scheme="https://rexlinbin.github.io/categories/%E4%BA%A7%E5%93%81/"/>
    
    
      <category term="资料" scheme="https://rexlinbin.github.io/tags/%E8%B5%84%E6%96%99/"/>
    
      <category term="刷量" scheme="https://rexlinbin.github.io/tags/%E5%88%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>安卓与“Proguard”——安卓的代码混淆</title>
    <link href="https://rexlinbin.github.io/2018/08/19/proguard/"/>
    <id>https://rexlinbin.github.io/2018/08/19/proguard/</id>
    <published>2018-08-19T06:50:51.000Z</published>
    <updated>2018-08-20T03:12:53.717Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><p>##什么是代码混淆</p><p>混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。被混淆过的程序代码，仍然遵照原来的档案格式和指令集，执行结果也与混淆前一样，只是混淆器将代码中的所有变量、函数、类的名称变为简短的英文字母代号，在缺乏相应的函数名和程序注释的况下，即使被反编译，也将难以阅读。同时混淆是不可逆的，在混淆的过程中一些不影响正常运行的信息将永久丢失，这些信息的丢失使程序变得更加难以理解。</p><p>##为什么要进行代码混淆</p><p>Java 是一种跨平台的、解释型语言，Java 源代码编译成中间”字节码”存储于 class 文件中。由于跨平台的需要，Java 字节码中包括了很多源代码信息，如变量名、方法名，并且通过这些名称来访问变量和方法，这些符号带有许多语义信息，很容易被反编译成 Java 源代码。为了防止这种现象，我们可以使用 Java 混淆器对 Java 字节码进行混淆。</p><p>混淆器的作用不仅仅是保护代码，它也有精简编译后程序大小的作用。以“ProGuard”为例，“ProGuard”的主要作用就是混淆，同时它还能对字节码进行缩减体积、优化等。由于对变量名和方法名进行缩减，以及前面所说过的部分不影响正常运行的信息会被丢失，使得编译后的jar文件的体积减少，文件精简。</p><p>##通过什么方式进行代码混淆</p><p>目前，主流的代码混淆的方式，就是使用“Proguard”，同时，你也可以在网上搜代码混淆，代码加固等等服务，可以轻易的搜索到诸如“360加固”、“爱加密”之类第三方的服务。那么他们的区别在哪里：<br>1&gt;使用工具，就是在你自己的电脑上，通过配置“Proguard”之类的工具，自己进行代码混淆，自己编译，自己调试。而使用第三方服务，就是将你自己的APK，上传到他们的网站，他们帮你进行混淆，混淆/加固完成，再将混淆后的APK发回来给你。<br>2&gt;使用工具，APK自始至终都在你自己手里，如果使用第三方的服务，原始APK就需要传给别人，这样增加了不安全性，当然你有可能会说，别人那么大间公司怎么觊觎你的APK？对于这个问题的看法就因人而异，像我实习那时处理我公司的那个项目，我的“leader”明确要求自己使用工具手动混淆，不能使用第三方的服务，不能将APK传给别人。</p><p>##什么是“ProGuard”</p><p>“ProGuard”是一个混淆代码的开源项目。它的主要作用就是混淆，当然它还能对字节码进行缩减体积、优化等，但是对于我们来说，体积压缩以及优化功能，还不是最重要的。我们真正在乎的，就是他的混淆功能。这是对“ProGuard”简介，如果你想看详细的，这里附上官网地址：<a href="http://proguard.sourceforge.net/" target="_blank" rel="noopener">http://proguard.sourceforge.net/</a></p><p>“ProGuard”可以进行哪些优化？</p><p>以下资料，来自网络：除了在压缩操作删除的无用类，字段和方法外，“ProGuard”也能在字节码级提供性能优化，内部方法有：</p><blockquote><p>常量表达式求值。<br>删除不必要的字段存取。<br>删除不必要的方法调用。<br>删除不必要的分支。<br>删除不必要的比较和instanceof验证。<br>删除未使用的代码。<br>删除只写字段。<br>删除未使用的方法参数。<br>像push/pop简化一样的各种各样的peephole优化。<br>在可能的情况下为类添加static和final修饰符。<br>在可能的情况下为方法添加private, static和final修饰符。<br>在可能的情况下使get/set方法成为内联的。<br>当接口只有一个实现类的时候，就取代它。<br>选择性的删除日志代码。实际的优化效果是依赖于你的代码和执行代码的虚拟机的。简单的虚拟机比有复杂JIT编译器的高级虚拟机更有效。无论如何，你的字节码会变得更小。</p></blockquote><p>仍有一些明显需要优化的技术不被支持：</p><blockquote><p>使非final的常量字段成为内联。<br>像get/set方法一样使其他方法成为内联。<br>将常量表达式移到循环之外。</p></blockquote><p>##如何使用“ProGuard”</p><p>前面说了混淆代码的起因和意义，也介绍了“ProGuard”各种好处，现在说说怎么使用这个工具。首先，以下说明全部基于”Eclipse”开发环境，Android2.3以后版本。在Android 2.3以前，混淆Android代码只能手动添加proguard来实现代码混淆，非常不方便。而2.3以后，Google已经将这个工具加入到了SDK的工具集里。该工具的具体路径：SDK\tools\proguard。当创建一个新的Android工程时，在工程目录的根路径下，会出现一个proguard的配置文件proguard.cfg。也就是说，我们可以通过简单的配置，在我们的elipse工程中直接使用ProGuard混淆Android工程。</p><p>##如何启动“ProGuard”</p><p>在工程的根路径下，找到”project-properties.txt”文件，源码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># This file is automaticallygenerated by Android Tools.</span><br><span class="line"># Do not modify this file -- YOURCHANGES WILL BE ERASED!</span><br><span class="line">#</span><br><span class="line"># This file must be checked inVersion Control Systems.</span><br><span class="line">#</span><br><span class="line"># To customize properties used bythe Ant build system edit</span><br><span class="line"># &quot;ant.properties&quot;, andoverride values to adapt the script to your</span><br><span class="line"># project structure.</span><br><span class="line">#</span><br><span class="line"># To enable ProGuard to shrink andobfuscate your code,uncomment this (available properties: sdk.dir,user.home):</span><br><span class="line"># proguard.config=$&#123;sdk.dir&#125;/tools/proguard/proguard-android.txt:proguard-project.txt</span><br><span class="line"># Project target.</span><br><span class="line">target=android-22</span><br></pre></td></tr></table></figure><p></p><p>你只要将倒数第三行那段代码，前面那个“#”号去掉，就能启动“ProGuard”工具。现在进行导包操作，在导包的过程当中，“Eclipse”会自动使用“ProGuard”工具。另外需要说明的一点是，你直接“run”到设备的应用是没有经过混淆的，即便你已经启动了“ProGuard”工具，只有手动导包之后所获得的APK，才是经过混淆工具处理过的。</p><p>##如何配置“ProGuard”</p><p>混淆文件前面说了如何启动“ProGuard”工具，对于一些极简单的工程（没有引用第三方库，没有自定义View，没有调用“native”层的方法），比如你的一个测试“demo”，可能不用配置什么，只要启动工具就好，混淆工作就这样完成了。但是对于较复杂的工程，我们需要手动配置一些东西才能保证混淆过程正常完成，以及混淆之后的APK正常运行。那么为什么复杂的工程就一定要手动配置？究其根本原因就是：不是什么东西都能被混淆的，有些代码混淆之后，它所对应的功能就没法使用。这主要体现在两个地方：<br>1.所有第三方引用库不能混淆，只要混淆，基本都是要出错的。<br>2.诸如自定义“View”，“native”层的方法，等等都不能被混淆，混淆之后其对应的功能都要出错，这类代码比较多，我在这里只列举了两个，后面我会详细记录一些。配置混淆文件就是为了告诉系统，某些东西不能混淆，以免我的APP会出错，现在详细介绍一<br>下如何配置“ProGuard”混淆文件。</p><p>两个与混淆相关的配置文件</p><blockquote><p>1.默认配置：工程刚创建的时候，开发环境其实已经默认配置好了混淆设置，你可以在“Eclipse路径\sdk\tools\proguard\”路径下面，找到一个“proguard-android.txt”文件，该文件是开发环境自动配置，混淆设置，这也是为什么对于极简单的项目而言，自己不用另外配置，系统默认配置就能满足。对于默认配置这里只做路径介绍，接下来是重点问题，如何根据项目具体状况，自行配置混淆文件。</p><p>2.自定义配置：在项目的根路径下，有个文件：proguard-project.txt。该文件就是手动进行配置的地方。我们需要按照一定语法规则，根据项目实际状况，编写该文件，这样才能正常通过混淆过程。</p></blockquote><p>自定义配置的具体规则</p><p>在“proguard-project.txt”文件里面编写混淆规则，其实只有一个目的：如果某个类混淆后，将会导致应用无法正常运行（或者部分功能无法正常运行）那么就要在配置文件里，声明不要混淆这些类。我不关心为什么这些类混淆之后会出错，只关心哪些类在混淆后出错，然后在文件里面声明不要去混淆这些类。当然如果你非得要刨根问底，你也可以在网上找更详细地资料。</p><p>通用规则</p><p>以下，是通用的，几乎所有工程都要避开的类（所谓避开，就是声明这些类不要被混淆）：</p><blockquote><p>四大组件以及系统基本的API不要混淆。<br>语法规则：-keep public class * extends xxxx<br>代码示例：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#所有“Activity”及其子类不要混淆，同理，所有“Service”、“BroadcastReceiver”等等系统级别的类，不要混淆。  </span><br><span class="line">-keep public class * extendsandroid.app.Activity  </span><br><span class="line">-keep public class * extendsandroid.app.Application  </span><br><span class="line">-keep public class * extendsandroid.app.Service  </span><br><span class="line">-keep public class * extendsandroid.content.BroadcastReceiver  </span><br><span class="line">-keep public class * extendsandroid.content.ContentProvider  </span><br><span class="line">-keep public class * extendsandroid.app.backup.BackupAgentHelper  </span><br><span class="line">-keep public class * extendsandroid.preference.Preference  </span><br><span class="line">-keep public classcom.android.vending.licensing.ILicensingService</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>保持”native”层的方法不要混淆。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclasseswithmembernamesclass * &#123;       </span><br><span class="line">   native&lt;methods&gt;;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>保持自定义控件，以及指定格式构造方法不要混淆。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-keepclasseswithmembers class * &#123;  </span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);  #保持自定义控件类不被混淆，指定格式的构造方法不去混淆  </span><br><span class="line">&#125;  </span><br><span class="line">-keepclasseswithmembers class * &#123;  </span><br><span class="line">    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>保持指定规则的方法不被混淆（Android layout 布局文件中为控件配置的onClick方法不能混淆）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembersclass * extends android.app.Activity &#123;  </span><br><span class="line">    public void *(android.view.View);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>保持自定义控件指定规则的方法不被混淆<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-keeppublic class * extends android.view.View &#123;   </span><br><span class="line">   public&lt;init&gt;(android.content.Context);  </span><br><span class="line">   public&lt;init&gt;(android.content.Context, android.util.AttributeSet);  </span><br><span class="line">   public&lt;init&gt;(android.content.Context, android.util.AttributeSet, int);  </span><br><span class="line">   public void set*(...);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>所有枚举类型不要混淆<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers enum * &#123;   </span><br><span class="line">   public static ** values();  </span><br><span class="line">   public static ** valueOf(java.lang.String);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>需要序列化和反序列化的类不能被混淆（注：Java反射用到的类也不能被混淆）<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#保持实现&quot;Serializable&quot;接口的类不被混淆  </span><br><span class="line">-keepnamesclass * implements java.io.Serializable  </span><br><span class="line">#保护实现接口Serializable的类中，指定规则的类成员不被混淆  </span><br><span class="line">-keepclassmembersclass * implements java.io.Serializable &#123;  </span><br><span class="line">    static final long serialVersionUID;  </span><br><span class="line">    private static finaljava.io.ObjectStreamField serialPersistentFields;  </span><br><span class="line">    !static !transient &lt;fields&gt;;  </span><br><span class="line">    private voidwriteObject(java.io.ObjectOutputStream);  </span><br><span class="line">    private voidreadObject(java.io.ObjectInputStream);  </span><br><span class="line">    java.lang.Object writeReplace();  </span><br><span class="line">    java.lang.Object readResolve();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>保持实现”Parcelable”接口的类不被混淆<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-keepclass * implements android.os.Parcelable &#123;   </span><br><span class="line">    public static finalandroid.os.Parcelable$Creator *;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>所有泛型不能混淆<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes Signature</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>假如项目中有用到注解，应加入这行配置<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keepattributes *Annotation*</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>保持R文件不被混淆，否则，你的反射是获取不到资源id的<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep class **.R$*&#123;*;&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>保护WebView对HTML页面的API不被混淆<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-keep class **.Webview2JsInterface &#123;*; &#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>如果你的项目中用到了webview的复杂操作 ，最好加入<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-keepclassmembers class * extends android.webkit.WebViewClient &#123;    </span><br><span class="line">     public void *(android.webkit.WebView,java.lang.String,android.graphics.Bitmap);  </span><br><span class="line">     public boolean *(android.webkit.WebView,java.lang.String);  </span><br><span class="line">&#125;  </span><br><span class="line">-keepclassmembers class * extends android.webkit.WebChromeClient &#123;    </span><br><span class="line">     public void *(android.webkit.WebView,java.lang.String);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>至此，主要通用规则已经介绍完毕，你可以直接拷贝到“ProGuard”配置文件里面去，这些规则都通用的。</p><p>##保持第三方引用库（第三方Jar包）不被混淆</p><p>前文已经讨论混淆通用规则，如果一个项目里面，没有引用第三方库，基本上你只要将前面的规则根据情况给抄上去，混淆基本都不会有什么问题。不过现在绝大多数项目（尤其是公司的项目）都会或多或少引入第三方库，前文也已经有提到，所有第三方引用库都不能够混淆，所以接下来我们就聊聊，如何保持第三方库不被混淆。其实保持第三方库不被混淆并不复杂，最关键的就是要细心+耐心。为什么呢？保持第三方库不被混淆，是要将你所引用的所有第三方库，按照一定语法格式，写在混淆配置文件里面，简单地说，就是将你”Eclipse”工程里的”Android Private Libraries”目录下面所有的第三方的引用包，按照给定语法格式，全部（注意是全部）写到你的”proguard.project.txt”文件里面。来让我们看图说话。</p><p><img src="https://www.2cto.com/uploadfile/Collfiles/20160716/20160716092030947.png" alt=""></p><p>一图胜千言，然后我们总结一下，对于每一个第三方的导入包，我们只要：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-libraryjars libs/xxxx.jar</span><br><span class="line">-dontwarn 包名.**</span><br><span class="line">-keep class 包名.** &#123; *;&#125;</span><br></pre></td></tr></table></figure><p></p><p>大部分的第三方包都能按照这个规则配置，有些第三方引用包，在其官方网站上面会有混淆代码配置说明，比如高德地图就有，这个时候你抄上去就可以了。<br>好了现在让我们把所有（对是所有）第三方包全都写上，写到手软~</p><p>运行程序，查漏补缺</p><p>一般来说，按照前面我们说讨论的规则配置之后，混淆过程都能正常通过（不会报错）。不过非常遗憾的是，混淆通过并不代表你APP就能运行，我们之前有提到过，有些东西原来不能混淆，当你混淆之后他的功能就会出错。当你完成了混淆后，只要运行你APP，每个功能都按一按，多玩一下，就有可能发生一些奇怪的事。所以我们才需要做查漏补缺。<br>首先执行混淆之后，我们能够在路径”proguard”下面发现新出现了四个文件：</p><blockquote><p>mapping.txt：表示混淆前后代码的对照表，这个文件非常重要。如果你的代码混淆后会产生bug的话，log提示中是混淆后的代码，希望定位到源代码的话就可以根据mapping.txt反推。每次发布都要保留它方便该版本出现问题时调出日志进行排查，它可以根据版本号或是发布时间命名来保存或是放进代码版本控制中。<br>dump.txt：描述apk内所有class文件的内部结构。<br>seeds.txt：列出了没有被混淆的类和成员。<br>usage.txt：列出了源代码中被删除在apk中不存在的代码。在我自己这个项目完成混淆代码之后，发生两件奇怪的事，现在说说怎么利用这些文件进行解决。<br>混淆过后的APP，所有列表（ListView）里的数据，都不显示，在确认了数据确实已经收到，就是没有显示之后，在usage.txt文件里面，发现了所有”ListView”的适配器，也就是说，混淆过后的Apk，代码里面已经没有适配器了，所以造成显示失败，而我当时所做的事，就是在混淆配置文件（proguard.project）文件里面，添加了如下代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#保持所有适配器类不被混淆，本应用中，不加这个将会导致适配器类加载失败，所有列表项没办法显示  </span><br><span class="line">-keep public class * extends android.widget.BaseAdapter</span><br></pre></td></tr></table></figure><p></p></blockquote><p>不过这个不算是混淆的配置规则，因为我的另外一个同时，跟我类似项目结构，但是他没有加这句，他的列表显示正常。这是使用”usage.txt”文件进行查漏补缺的例子了。</p><blockquote><p>混淆过后的APP，越用越卡（其实就是内存泄露），用着用着手机就会莫名其妙的死机了，不单单是应用卡死，整台手机都不动了。不论在APP里面进行什么操作，都会导致APP将手机给弄死了。这个异常最终不是通过前面四个文件来解决的，而是通过对APP功能进行考虑。基于所发生的现象，可以看出，一定有什么全局性东西，混淆之后发生错误，导致这个全局功能没法运行，但是却又不断请求，最终耗尽系统资源。最终确定的原因是，我们APP的推送以及IM功能，混淆之后没法工作，最终耗尽系统资源。那么解决的办法是，声明他不要被混淆。</p></blockquote><p>总结</p><p>我们聊了那么多的东西，先介绍了什么叫做代码混淆，然后介绍混淆方式选择，接着介绍如何启动以及配置混淆，最重要的当然就是配置混淆。其中包括通用规则，第三方包，以及根据混淆后的文件进行查漏补缺。至此，APP的代码混淆基础，介绍完毕。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;p&gt;##什么是代码混淆&lt;/p&gt;&lt;p&gt;混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编
      
    
    </summary>
    
      <category term="android" scheme="https://rexlinbin.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://rexlinbin.github.io/tags/android/"/>
    
      <category term="工具" scheme="https://rexlinbin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>无线干扰及检测技术</title>
    <link href="https://rexlinbin.github.io/2018/08/10/wifi-attack/"/>
    <id>https://rexlinbin.github.io/2018/08/10/wifi-attack/</id>
    <published>2018-08-10T03:01:41.000Z</published>
    <updated>2018-08-20T02:58:09.429Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><p>##前言<br>都听过一句话，没有网络安全就没有国家安全，网络安全一直是这几年的热议话题，未来战争是一个多元化的战争，网络战电子战成为主流必然是趋势所向。而信号干扰是这种战争的主流攻击手段，通过干扰手机、GPS、wifi，甚至卫星链路等电磁波的正常传输，可以影响到整个战争的走向。这里我们讨论的是基本的无线干扰，通过控制未加密的管理帧实现。</p><p>802.11标准将所有的数据包分为3种：数据、管理、控制。</p><p>####数据帧：<br>携带更高层次的数据，也是唯一可以从无线网络转发到有线网络的数据包</p><p>####控制帧：<br>通常与数据帧搭配使用，负责区域的清空、信道的取得以及载波监听的维护，并于收到数据时予以正面的应答，借此促进工作站间数据传输的可靠性</p><p>####管理帧：<br>信标帧(Beacons): 在无线设备中，定时依次按指定间隔发送的有规律的无线信号(类似心跳包)，主要用于定位和同步使用；</p><p>解除认证(Deauthentication)帧：解除身份认证，用于结束一段认证关系；</p><p>Probe(request and response)帧：探测区域内有哪些无线信号；</p><p>Authenticate(request and response)帧：身份验证；</p><p>Associate(request and response)帧：关联请求、响应；</p><p>Reassociate(request and response)帧：位于相同扩展服务区域，但在不同基本服务区域间游走的移动式工作站，再次使用分布式系统时，必须与网络重新关联；</p><p>Dissassociate(notify) 帧：取消关联。</p><p>##攻击原理<br>仔细观察管理帧的类型就会发现，如果攻击者伪造MAC地址，对受害者ap或设备发送指定帧，就会造成目标设备或ap的巨大影响。具体技术手段如下：</p><p>第一种：验证洪水攻击，俗称Authdos，通过随机生成大量mac地址，伪装设备向ap发送大量身份验证Authenticate请求帧，使请求数量超出ap承载能力，从而造成拒绝服务攻击，使正常用户无法连接ap。</p><p>图示：<br><img src="http://image.3001.net/images/20180815/1534263254_5b72ffd6825a8.png!small" alt=""><br>第二种：取消验证洪水攻击，俗称deauth攻击，通过伪造mac地址，伪装成目标ap已连接的设备，向ap发送Deauthentication解除认证帧，造成设备掉线，从而达到拒绝服务的目的。</p><p>图示：<br><img src="http://image.3001.net/images/20180815/1534263263_5b72ffdf45dcb.png!small" alt=""><br>破解无线密码时经常用到这种攻击，利用deauth帧解除设备的连接，从而嗅探到设备再次连接时的握手包，通过字典中的大量密码匹配，爆破穷举出无线密码。</p><p>第三种：关联洪水攻击，俗称asso攻击，主要针对空密码或已破解密码的无线信号，伪造大量设备，淹没ap的关联表，使ap无法给正常用户建立关联</p><p>图示：<br><img src="http://image.3001.net/images/20180815/1534263270_5b72ffe6b6802.png!small" alt=""><br>第四种：射频干扰攻击 RF jammingAttack，这种不再针对管理帧的漏洞，而是上升到物理干扰的层次，用噪声信号淹没射频信号导致系统失效。 这种干扰不分敌我，会影响到一片区域指定频带范围的信号，高考等重要国家考试屏蔽信号用的就是这个方法。</p><p>##攻击工具<br>纸上得来终觉浅，下面进行工具实操的演示：</p><p>第一个工具：aireplay-ng，这款工具利用的是上述中的deauth攻击。</p><p>首先：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">airmon-ngstart wlan0       将网卡置为监听模式</span><br><span class="line"></span><br><span class="line">airodump-ngwlan0mon –bssid 目标ap的ssid       开始侦听目标网络</span><br></pre></td></tr></table></figure><p></p><p><img src="http://image.3001.net/images/20180815/1534263532_5b7300ec9b15b.png!small" alt=""><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aireplay-ng-0 0 -a ap的ssid-c 设备的ssid wlan0mon 开始攻击</span><br></pre></td></tr></table></figure><p></p><p><img src="http://image.3001.net/images/20180815/1534263553_5b730101a63f3.png!small" alt=""></p><p>可以看到攻击起了作用，我的windows主机已经ping不通路由器了。</p><p><img src="http://image.3001.net/images/20180815/1534263571_5b7301137352c.png!small" alt=""></p><p>第二个工具：mdk3</p><p>这是mdk3的帮助文档：<br><img src="http://image.3001.net/images/20180815/1534263591_5b7301276bc92.png!small" alt=""></p><p>可以看到，a参数是第一种攻击——authdos攻击，d参数是第二种攻击——deauth攻击，b参数是信标泛洪攻击，伪造大量虚假ap，只能起到混淆的作用。</p><p>首先演示a参数，将网卡置成监听模式后，查找目标ap的mac地址：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">airodump-ngwlan0mon</span><br></pre></td></tr></table></figure><p></p><p>找到后，使用mdk3 wlan0mon a -a mac地址发起攻击：<br><img src="http://image.3001.net/images/20180815/1534263612_5b73013c3f7f0.png!small" alt=""></p><p>发起攻击后，我的windows主机死活连不上ap，还会在连接过程中重启适配器：<br><img src="http://image.3001.net/images/20180815/1534263737_5b7301b99018b.png!small" alt=""></p><p>再来试一下d参数，先来看一下d参数的帮助文档：<br><img src="http://image.3001.net/images/20180815/1534263699_5b730193cf316.png!small" alt=""></p><p>直接用d参数看起来杀伤范围比较大，还是用一下黑名单功能，只干扰自己的设备吧。</p><p>先把目标ap的设备mac地址加入blacklists.txt黑名单：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vimblack.txt</span><br></pre></td></tr></table></figure><p></p><p>开始攻击：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mdk3wlan0mon –c 目标ap的信道 –b~/blacklists.txt</span><br></pre></td></tr></table></figure><p></p><p><img src="http://image.3001.net/images/20180815/1534263762_5b7301d298709.png!small" alt=""></p><p>干扰成功。</p><p>第三个工具：esp8266<br><img src="http://image.3001.net/images/20180815/1534263826_5b7302123167c.png!small" alt=""></p><p>这是一款低功耗、高度集成的wifi芯片，将程序烧录进去后，用充电宝供电，不需要kali和无线适配器，也能进行无线干扰攻击，非常便携。</p><p>程序烧录后，手机连接控制板子的wifi，进入管理页面：<br><img src="http://image.3001.net/images/20180815/1534263852_5b73022c6f894.png!small" alt=""></p><p>选择好目标ap后，发起deauth攻击：<br><img src="http://image.3001.net/images/20180815/1534263896_5b73025808364.png!small" alt=""></p><p>被断开连接了。</p><p>第四个工具：airgeddon</p><p>安装：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/v1s1t0r1sh3r3/airgeddon.git</span><br><span class="line">cd airgeddon </span><br><span class="line">sudo bash airgeddon.sh</span><br></pre></td></tr></table></figure><p></p><p>选择无线网卡：<br><img src="http://image.3001.net/images/20180815/1534263921_5b730271ab7ba.png!small" alt=""></p><p>进入监听模式，并开始dos攻击：</p><p><img src="http://image.3001.net/images/20180815/1534263948_5b73028c00dd8.png!small" alt=""><br><img src="http://image.3001.net/images/20180815/1534263978_5b7302aa896aa.png!small" alt=""></p><p>这款工具其实就是很多工具的集合，最后调用的还是mdk3和aireplay，只是设计的更新手化一些。</p><p>##检测及防御手段<br>以上工具演示完可以发现，想要进行无线干扰攻击非常简单，不需要任何基础就可以对无线网络造成巨大影响。虽然脚本小子很容易就能破坏网络，但是他们也很容易被发现。</p><p>对于检测攻击来说，kismet和wireshark等嗅探工具都是不错的选择。如果想对网络发起监控，对可疑行为报警，可以选择kismet。如果想获得更多的packet信息，可以选择wireshark、omnipeek、commview等抓包工具，具体取决于哪款支持你的无线网卡。因为commview支持我的笔记本集成网卡，下面就用它来做一个抓包演示：<br><img src="http://image.3001.net/images/20180815/1534264089_5b73031981c33.png!small" alt=""><br>选择只抓管理帧的包并忽略beacons帧.</p><p>aireplay-ng的取消验证洪水攻击：<br><img src="http://image.3001.net/images/20180815/1534264110_5b73032ee3bbd.png!small" alt=""></p><p>可以看到大量的deauth解除认证帧。</p><p>mdk3的身份验证洪水攻击：<br><img src="http://image.3001.net/images/20180815/1534264122_5b73033ad339b.png!small" alt=""></p><p>可以看到大量设备的身份验证请求。</p><p>配合esp8266和kali来演示一下kismet的用法:</p><p>输入 sudo kismet –c wlan0mon 就进入了kistmet的主界面：<br><img src="http://image.3001.net/images/20180815/1534264146_5b73035285174.png!small" alt=""><br><img src="http://image.3001.net/images/20180815/1534264178_5b730372d8cf2.png!small" alt=""></p><p>windows-alerts选项，可以在检测到异常情况时报警。</p><p>用esp8266发起deauth攻击：<br><img src="http://image.3001.net/images/20180815/1534264203_5b73038b34301.png!small" alt=""></p><p>检测到了攻击。</p><p>可以发现，虽然干扰攻击很容易被检测到，但是很难取证，因为源头的mac地址都是伪造的，所以提前做好防御才是解决的方法。</p><p>为防止这类攻击，最佳解决防范是尽量使用以太网，避免无线网络。如果必须使用，可以采取降低无线功率的手段降低被攻击概率，但大多数物联网设备都不具备这个功能。其实也不必担心，WPA3已经慢慢出现在公众的视线中，wpa3和wpa2核心差异之一是不允许伪造身份验证或解除关联数据帧，如果你的设备支持wpa3，可以升级以杜绝无线干扰攻击。</p><p>来自FreeBuf.COM</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;p&gt;##前言&lt;br&gt;都听过一句话，没有网络安全就没有国家安全，网络安全一直是这几年的热议话题，未来战争是一个多元化的战争，网络战电子战成为主流必然是趋势所向。而
      
    
    </summary>
    
      <category term="工具" scheme="https://rexlinbin.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="https://rexlinbin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="无线" scheme="https://rexlinbin.github.io/tags/%E6%97%A0%E7%BA%BF/"/>
    
      <category term="检测" scheme="https://rexlinbin.github.io/tags/%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android 脱壳工具</title>
    <link href="https://rexlinbin.github.io/2018/08/04/android-unpack/"/>
    <id>https://rexlinbin.github.io/2018/08/04/android-unpack/</id>
    <published>2018-08-04T03:39:21.000Z</published>
    <updated>2018-08-20T02:57:55.554Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><h1 id="drizzleDumper介绍"><a href="#drizzleDumper介绍" class="headerlink" title="drizzleDumper介绍"></a>drizzleDumper介绍</h1><p>drizzleDumper是一款基于内存搜索的Android脱壳工具。是根据strazzere大神的android-unpacker优化改造而成，这是一款ndk写的动态Android脱壳的工具，原理简单来说就是ptrace，然后在内存中匹配特征码和dex的magic，最后dump到文件。</p><h1 id="apk文件结构"><a href="#apk文件结构" class="headerlink" title="apk文件结构"></a>apk文件结构</h1><p><img src="http://f.talkingdata.com/uploads/article/20180807/15fb9d86cf8a4e92b7c701bc53fbbda5.png" alt=""></p><h1 id="dex文件头结构"><a href="#dex文件头结构" class="headerlink" title="dex文件头结构"></a>dex文件头结构</h1><p><img src="http://f.talkingdata.com/uploads/article/20180807/bef6b1c120ae75d75066cc656f6887ca.png" alt=""></p><h1 id="drizzleDumper修改优化的地方："><a href="#drizzleDumper修改优化的地方：" class="headerlink" title="drizzleDumper修改优化的地方："></a>drizzleDumper修改优化的地方：</h1><p>1.android-unpacker基本上就是匹配odex magic的函数时（下图），而drizzleDumper不管odex了，专心匹配dex的magic。</p><p><img src="http://image.3001.net/images/20160523/14640077256907.png!small" alt=""></p><p>2.android-unpacker用pread（下图），而drizzleDumper换了read和lseek，具体就不说为啥了，这是非常重要的一点。</p><p><img src="http://image.3001.net/images/20160523/14640087875257.png!small" alt=""></p><p>3.直接抛弃了android-unpacker中的壳的特征匹配这一整块儿内容。</p><p>4.android-unpacker只匹配和dump一次，而drizzleDumper引入了双循环机制，这点对脱壳成功也非常重要。</p><p>5.android-unpacker在peek_memory（下图）中进行magic匹配，drizzleDumper改了逻辑，换了一种匹配方式。</p><p><img src="http://image.3001.net/images/20160523/14640089606117.png!small" alt=""></p><p>6.另外还增加了一匹配种方法，来增强匹配的成功率。</p><p>7.引入了wait_times机制（很无奈，等待真正的程序dex加载到内存）</p><p>8.其他..</p><h1 id="drizzleDumper使用"><a href="#drizzleDumper使用" class="headerlink" title="drizzleDumper使用"></a>drizzleDumper使用</h1><p>1.获取root权限<br>执行adb root命令 或者 adb shell su</p><p>2.将drizzleDumper文件adb push到/data/local/tmp路径下</p><p>3.安装apk<br>adb install apk</p><p>4.运行apk</p><p>5.执行脱壳工具<br>adb shell ./data/local/tmp drizzleDumper apk包名 2</p><p>6.dump下来的dex文件会存到/data/local/tmp路径下，将文件下载下来</p><p>7.剩下就可以通过dex2jar等工具，解析源码了。</p><h1 id="drizzleDumper实战测试"><a href="#drizzleDumper实战测试" class="headerlink" title="drizzleDumper实战测试"></a>drizzleDumper实战测试</h1><p><img src="http://image.3001.net/images/20160523/14640095391495.png!small" alt=""></p><p><img src="http://image.3001.net/images/20160523/14640095864826.png!small" alt=""></p><p><img src="http://image.3001.net/images/20160523/14640097832148.png!small" alt=""></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;h1 id=&quot;drizzleDumper介绍&quot;&gt;&lt;a href=&quot;#drizzleDumper介绍&quot; class=&quot;headerlink&quot; title=&quot;dri
      
    
    </summary>
    
      <category term="android" scheme="https://rexlinbin.github.io/categories/android/"/>
    
      <category term="工具" scheme="https://rexlinbin.github.io/categories/android/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="android" scheme="https://rexlinbin.github.io/tags/android/"/>
    
      <category term="unpack" scheme="https://rexlinbin.github.io/tags/unpack/"/>
    
      <category term="工具" scheme="https://rexlinbin.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="https://rexlinbin.github.io/2018/07/16/linux-command/"/>
    <id>https://rexlinbin.github.io/2018/07/16/linux-command/</id>
    <published>2018-07-16T08:42:34.000Z</published>
    <updated>2018-08-20T02:58:22.308Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><h3 id="Linux路径"><a href="#Linux路径" class="headerlink" title="Linux路径"></a>Linux路径</h3><p>linux绝对路径以”/“开头</p><h3 id="显示当前文件列表"><a href="#显示当前文件列表" class="headerlink" title="显示当前文件列表"></a>显示当前文件列表</h3><p>ll或ls</p><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>如果dir2目录不存在，则可以直接使用<br>cp -r dir1 dir2 即可。<br>如果dir2目录已存在，则需要使用<br>cp -r dir1/. dir2</p><h3 id="统计某文件夹下文件的个数"><a href="#统计某文件夹下文件的个数" class="headerlink" title="统计某文件夹下文件的个数"></a>统计某文件夹下文件的个数</h3><p>ls -l |grep “^-“|wc -l</p><h2 id="统计某文件夹下目录的个数"><a href="#统计某文件夹下目录的个数" class="headerlink" title="统计某文件夹下目录的个数"></a>统计某文件夹下目录的个数</h2><p>ls -l |grep “^ｄ”|wc -l</p><h3 id="统计文件夹下文件的个数，包括子文件夹里的"><a href="#统计文件夹下文件的个数，包括子文件夹里的" class="headerlink" title="统计文件夹下文件的个数，包括子文件夹里的"></a>统计文件夹下文件的个数，包括子文件夹里的</h3><p>ls -lR|grep “^-“|wc -l</p><h3 id="查看文件夹下文件大小"><a href="#查看文件夹下文件大小" class="headerlink" title="查看文件夹下文件大小"></a>查看文件夹下文件大小</h3><p>du -sh *</p><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>mv abc.txt 1234.txt</p><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>find lib -type f -name “*.0” -exec rm -f {} \; 查找末尾.0的文件删除<br>rm -f 强制删除文件<br>rm -rf 向下递归删除文件夹</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>cat [-n] 文件名 -n代表显示行号</p><h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p>chmod -R 755 文件名</p><h3 id="运行jar和停止jar"><a href="#运行jar和停止jar" class="headerlink" title="运行jar和停止jar"></a>运行jar和停止jar</h3><p>java -jar jar包 运行jar包 当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序 退出<br>java -jar jar包 &amp; &amp;代表在后台运行。<br>特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。<br>nohup java -jar jar包 &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行<br>当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。<br>nohup java -jar jar包 &gt;temp.txt &amp; command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。<br>jobs 查看后台运行任务<br>fg 任务号 调到前台<br>ps aux|grep jar包 查看jar包进程<br>kill -9 查到的进程 停止jar运行</p><h3 id="查看系统资源占用"><a href="#查看系统资源占用" class="headerlink" title="查看系统资源占用"></a>查看系统资源占用</h3><p>free －b －s5 每5秒刷新 查看内存<br>top -c 每5秒刷新<br>df 查看磁盘空间<br>glances 查看系统工具</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>linux查看日志文件内容命令tail、cat、tac、head、echo<br>tail -f test.log</p><h2 id="你会看到屏幕不断有内容被打印出来-这时候中断第一个进程Ctrl-C"><a href="#你会看到屏幕不断有内容被打印出来-这时候中断第一个进程Ctrl-C" class="headerlink" title="你会看到屏幕不断有内容被打印出来. 这时候中断第一个进程Ctrl-C,"></a>你会看到屏幕不断有内容被打印出来. 这时候中断第一个进程Ctrl-C,</h2><p>linux 如何显示一个文件的某几行(中间几行)<br>从第3000行开始，显示1000行。即显示3000~3999行<br>cat filename | tail -n +3000 | head -n 1000<br>显示1000行到3000行<br>cat filename| head -n 3000 | tail -n +1000<br>*注意两种方法的顺序<br>分解：<br>tail -n 1000：显示最后1000行<br>tail -n +1000：从1000行开始显示，显示1000行以后的<br>head -n 1000：显示前面1000行<br>用sed命令<br>sed -n ‘5,10p’ filename 这样你就可以只查看文件的第5行到第10行。</p><h2 id="例：cat-mylog-log-tail-n-1000-输出mylog-log-文件最后一千行"><a href="#例：cat-mylog-log-tail-n-1000-输出mylog-log-文件最后一千行" class="headerlink" title="例：cat mylog.log | tail -n 1000 #输出mylog.log 文件最后一千行"></a>例：cat mylog.log | tail -n 1000 #输出mylog.log 文件最后一千行</h2><p>cat主要有三大功能：<br>1.一次显示整个文件。$ cat filename<br>2.从键盘创建一个文件。$ cat &gt; filename<br>只能创建新文件,不能编辑已有文件.<br>3.将几个文件合并为一个文件： $cat file1 file2 &gt; file<br>参数：<br>-n 或 –number 由 1 开始对所有输出的行数编号<br>-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号<br>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行<br>-v 或 –show-nonprinting<br>例：<br>把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里<br>cat -n textfile1 &gt; textfile2<br>把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。<br>cat -b textfile1 textfile2 &gt;&gt; textfile3</p><p>把test.txt文件扔进垃圾箱，赋空值test.txt<br>cat /dev/null &gt; /etc/test.txt</p><h2 id="注意：-gt-意思是创建，-gt-gt-是追加。千万不要弄混了。"><a href="#注意：-gt-意思是创建，-gt-gt-是追加。千万不要弄混了。" class="headerlink" title="注意：&gt;意思是创建，&gt;&gt;是追加。千万不要弄混了。"></a>注意：&gt;意思是创建，&gt;&gt;是追加。千万不要弄混了。</h2><p>tac (反向列示)<br>tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，</p><h2 id="而-tac-则是由最后一行到第一行反向在萤幕上显示出来！"><a href="#而-tac-则是由最后一行到第一行反向在萤幕上显示出来！" class="headerlink" title="而 tac 则是由最后一行到第一行反向在萤幕上显示出来！"></a>而 tac 则是由最后一行到第一行反向在萤幕上显示出来！</h2><p>在Linux中echo命令用来在标准输出上显示一段字符，比如：<br>echo “the echo command test!”<br>这个就会输出“the echo command test!”这一行文字！<br>echo “the echo command test!”&gt;a.sh<br>这个就会在a.sh文件中输出“the echo command test!”这一行文字！<br>该命令的一般格式为： echo [ -n ] 字符串其中选项n表示输出文字后不换行；字符串能加引号，也能不加引号。<br>用echo命令输出加引号的字符串时，将字符串原样输出；<br>用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。</p><h3 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h3><p>q<br>ctrl c</p><h3 id="XShell5工具"><a href="#XShell5工具" class="headerlink" title="XShell5工具"></a>XShell5工具</h3><p>上传文件到linux<br>-b 以二进制方式，默认为文本方式。<br>-e 对所有控制字符转义。<br>如果要保证上传的文件内容在服务器端保存之后与原始文件一致，最好同时设置这两个标志，如下所示方式使用：<br>rz –bey</p><p>下载一个文件<br>sz filename<br>下载多个文件<br>sz filename1 filename2<br>下载dir目录下的文件，不包括文件夹<br>sz dir/*</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;Linux路径&quot;&gt;&lt;a href=&quot;#Linux路径&quot; class=&quot;headerlink&quot; title=&quot;Linux路径&quot;&gt;&lt;/a&gt;Linux路
      
    
    </summary>
    
      <category term="linux" scheme="https://rexlinbin.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://rexlinbin.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常处理</title>
    <link href="https://rexlinbin.github.io/2018/07/06/java-throwable/"/>
    <id>https://rexlinbin.github.io/2018/07/06/java-throwable/</id>
    <published>2018-07-06T06:01:24.000Z</published>
    <updated>2018-08-20T02:58:33.845Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><h2 id="Java异常类层次结构图"><a href="#Java异常类层次结构图" class="headerlink" title="Java异常类层次结构图"></a>Java异常类层次结构图</h2><p><img src="https://images2015.cnblogs.com/blog/641003/201607/641003-20160706232044280-355354790.png" alt="java异常类层次结构图"></p><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>异常的英文单词是exception，字面翻译就是“意外、例外”的意思，也就是非正常情况。事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，通过异常机制来处理程序运行期间出现的错误。通过异常机制，我们可以更好地提升程序的健壮性。</p><h3 id="unchecked-exception（非检查异常）"><a href="#unchecked-exception（非检查异常）" class="headerlink" title="unchecked exception（非检查异常）"></a>unchecked exception（非检查异常）</h3><p>也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</p><h3 id="checked-exception（检查异常，编译异常）"><a href="#checked-exception（检查异常，编译异常）" class="headerlink" title="checked exception（检查异常，编译异常）"></a>checked exception（检查异常，编译异常）</h3><p>也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p><h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><p>有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><h3 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h3><p>是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><h3 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h3><p>是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。<br>可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h3 id="应该catch什么"><a href="#应该catch什么" class="headerlink" title="应该catch什么"></a>应该catch什么</h3><p>其实只要是Throwable和其子类都是可以throw和catch的，那么如果在需要统一处理异常的地方，我们应该catch (Throwable th) 还是 catch (Exception)呢？<br>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。先不考虑有其他的类继承了Throwable的情况下，第一种catch相当于比第二种catch多捕捉了把Error和其子类。<br>那么究竟Error是否需要捕捉呢？JDK中Error类的的注释（如下）里提到过，Error是一种严重的问题，应用程序不应该捕捉它。<br>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a “normal” condition, is also a subclass of Error because most applications should not try to catch it.<br>A method is not required to declare in its throws clause any subclasses of Error that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur.<br>Java Lanuage Spec 7 中也提到：Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)“来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。<br>The class Error is a separate subclass ofThrowable, distinct from Exception in the class<br>hierarchy, to allow programs to use the idiom “} catch (Exception e) { ” (§11.2.3)<br>to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible.<br>已经不难看出，Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用。</p><h3 id="Error可以catch吗？-可以catch了后做些其他处理吗？"><a href="#Error可以catch吗？-可以catch了后做些其他处理吗？" class="headerlink" title="Error可以catch吗？ 可以catch了后做些其他处理吗？"></a>Error可以catch吗？ 可以catch了后做些其他处理吗？</h3><p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;Java异常类层次结构图&quot;&gt;&lt;a href=&quot;#Java异常类层次结构图&quot; class=&quot;headerlink&quot; title=&quot;Java异常类层次
      
    
    </summary>
    
      <category term="java" scheme="https://rexlinbin.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://rexlinbin.github.io/tags/java/"/>
    
      <category term="exception" scheme="https://rexlinbin.github.io/tags/exception/"/>
    
      <category term="throwable" scheme="https://rexlinbin.github.io/tags/throwable/"/>
    
  </entry>
  
  <entry>
    <title>Android Mac 环境配置</title>
    <link href="https://rexlinbin.github.io/2018/07/04/android-mac/"/>
    <id>https://rexlinbin.github.io/2018/07/04/android-mac/</id>
    <published>2018-07-04T09:16:11.000Z</published>
    <updated>2018-08-20T02:58:57.736Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><h2 id="Java环境"><a href="#Java环境" class="headerlink" title="Java环境"></a>Java环境</h2><p>1）下载安装</p><p>mac系统一般默认会安装jdk 1.6,路径为/System/Library/Java/JavaVirtualMachines/1.6.0.jdk,但有时候可能需要下载更高版本的jdk</p><p>官网下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>2）配置</p><p>配置方式为 vim ~/.bash_profile,增加或修改</p><p>export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</p><p>export JAVA_HOME</p><p>export PATH=$PATH:$JAVA_HOME</p><p>最后重新加载profile</p><p>source ~/.bash_profile</p><p>3）验证</p><p>java -version</p><p>可以查看到当前版本信息代表安装配置成功。</p><h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><p>1） 下载安装</p><p>官网下载：<a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="noopener">http://developer.android.com/tools/studio/index.html</a></p><p>得到的dmg文件直接拖到Applications安装，注意安装路径</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;Java环境&quot;&gt;&lt;a href=&quot;#Java环境&quot; class=&quot;headerlink&quot; title=&quot;Java环境&quot;&gt;&lt;/a&gt;Java环境&lt;/h
      
    
    </summary>
    
      <category term="android" scheme="https://rexlinbin.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://rexlinbin.github.io/tags/android/"/>
    
      <category term="mac" scheme="https://rexlinbin.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>冷月当空，雪魂飞舞</title>
    <link href="https://rexlinbin.github.io/2018/07/04/hello-world/"/>
    <id>https://rexlinbin.github.io/2018/07/04/hello-world/</id>
    <published>2018-07-04T08:58:08.061Z</published>
    <updated>2018-07-04T08:58:08.061Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --><p>欢迎来到冷月阁</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="这是一个小小的博客"><a href="#这是一个小小的博客" class="headerlink" title="这是一个小小的博客"></a>这是一个小小的博客</h3><p>进行必要的知识储备，现如今是信息时代，知识更新迅速，需要不断学习，才能保证不被时代丢弃，我是一个程序员，所以这里会是我各种技术文档的存放地，当然也可能会存放其他文章，视情况而定，所以出现其他类文章，大家不要惊讶，哈哈。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Aug 30 2018 11:56:35 GMT+0800 (CST) --&gt;&lt;p&gt;欢迎来到冷月阁&lt;/p&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
