<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>冷月阁</title>
  
  <subtitle>知识库</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rexlinbin.github.io/"/>
  <updated>2018-07-16T08:53:05.699Z</updated>
  <id>https://rexlinbin.github.io/</id>
  
  <author>
    <name>冷月灬雪魂</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="https://rexlinbin.github.io/2018/07/16/linux-command/"/>
    <id>https://rexlinbin.github.io/2018/07/16/linux-command/</id>
    <published>2018-07-16T08:42:34.000Z</published>
    <updated>2018-07-16T08:53:05.699Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 18 2018 10:49:06 GMT+0800 (CST) --><h3 id="Linux路径"><a href="#Linux路径" class="headerlink" title="Linux路径"></a>Linux路径</h3><p>linux绝对路径以”/“开头</p><h3 id="显示当前文件列表"><a href="#显示当前文件列表" class="headerlink" title="显示当前文件列表"></a>显示当前文件列表</h3><p>ll或ls</p><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>如果dir2目录不存在，则可以直接使用<br>cp -r dir1 dir2 即可。<br>如果dir2目录已存在，则需要使用<br>cp -r dir1/. dir2</p><h3 id="统计某文件夹下文件的个数"><a href="#统计某文件夹下文件的个数" class="headerlink" title="统计某文件夹下文件的个数"></a>统计某文件夹下文件的个数</h3><p>ls -l |grep “^-“|wc -l</p><h2 id="统计某文件夹下目录的个数"><a href="#统计某文件夹下目录的个数" class="headerlink" title="统计某文件夹下目录的个数"></a>统计某文件夹下目录的个数</h2><p>ls -l |grep “^ｄ”|wc -l</p><h3 id="统计文件夹下文件的个数，包括子文件夹里的"><a href="#统计文件夹下文件的个数，包括子文件夹里的" class="headerlink" title="统计文件夹下文件的个数，包括子文件夹里的"></a>统计文件夹下文件的个数，包括子文件夹里的</h3><p>ls -lR|grep “^-“|wc -l</p><h3 id="查看文件夹下文件大小"><a href="#查看文件夹下文件大小" class="headerlink" title="查看文件夹下文件大小"></a>查看文件夹下文件大小</h3><p>du -sh *</p><h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>mv abc.txt 1234.txt</p><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>find lib -type f -name “*.0” -exec rm -f {} \; 查找末尾.0的文件删除<br>rm -f 强制删除文件<br>rm -rf 向下递归删除文件夹</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>cat [-n] 文件名 -n代表显示行号</p><h3 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h3><p>chmod -R 755 文件名</p><h3 id="运行jar和停止jar"><a href="#运行jar和停止jar" class="headerlink" title="运行jar和停止jar"></a>运行jar和停止jar</h3><p>java -jar jar包 运行jar包 当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序 退出<br>java -jar jar包 &amp; &amp;代表在后台运行。<br>特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。<br>nohup java -jar jar包 &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行<br>当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。<br>nohup java -jar jar包 &gt;temp.txt &amp; command &gt;out.file是将command的输出重定向到out.file文件，即输出内容不打印到屏幕上，而是输出到out.file文件中。<br>jobs 查看后台运行任务<br>fg 任务号 调到前台<br>ps aux|grep jar包 查看jar包进程<br>kill -9 查到的进程 停止jar运行</p><h3 id="查看系统资源占用"><a href="#查看系统资源占用" class="headerlink" title="查看系统资源占用"></a>查看系统资源占用</h3><p>free －b －s5 每5秒刷新 查看内存<br>top -c 每5秒刷新<br>df 查看磁盘空间<br>glances 查看系统工具</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>linux查看日志文件内容命令tail、cat、tac、head、echo<br>tail -f test.log</p><h2 id="你会看到屏幕不断有内容被打印出来-这时候中断第一个进程Ctrl-C"><a href="#你会看到屏幕不断有内容被打印出来-这时候中断第一个进程Ctrl-C" class="headerlink" title="你会看到屏幕不断有内容被打印出来. 这时候中断第一个进程Ctrl-C,"></a>你会看到屏幕不断有内容被打印出来. 这时候中断第一个进程Ctrl-C,</h2><p>linux 如何显示一个文件的某几行(中间几行)<br>从第3000行开始，显示1000行。即显示3000~3999行<br>cat filename | tail -n +3000 | head -n 1000<br>显示1000行到3000行<br>cat filename| head -n 3000 | tail -n +1000<br>*注意两种方法的顺序<br>分解：<br>tail -n 1000：显示最后1000行<br>tail -n +1000：从1000行开始显示，显示1000行以后的<br>head -n 1000：显示前面1000行<br>用sed命令<br>sed -n ‘5,10p’ filename 这样你就可以只查看文件的第5行到第10行。</p><h2 id="例：cat-mylog-log-tail-n-1000-输出mylog-log-文件最后一千行"><a href="#例：cat-mylog-log-tail-n-1000-输出mylog-log-文件最后一千行" class="headerlink" title="例：cat mylog.log | tail -n 1000 #输出mylog.log 文件最后一千行"></a>例：cat mylog.log | tail -n 1000 #输出mylog.log 文件最后一千行</h2><p>cat主要有三大功能：<br>1.一次显示整个文件。$ cat filename<br>2.从键盘创建一个文件。$ cat &gt; filename<br>只能创建新文件,不能编辑已有文件.<br>3.将几个文件合并为一个文件： $cat file1 file2 &gt; file<br>参数：<br>-n 或 –number 由 1 开始对所有输出的行数编号<br>-b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号<br>-s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行<br>-v 或 –show-nonprinting<br>例：<br>把 textfile1 的档案内容加上行号后输入 textfile2 这个档案里<br>cat -n textfile1 &gt; textfile2<br>把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。<br>cat -b textfile1 textfile2 &gt;&gt; textfile3</p><p>把test.txt文件扔进垃圾箱，赋空值test.txt<br>cat /dev/null &gt; /etc/test.txt</p><h2 id="注意：-gt-意思是创建，-gt-gt-是追加。千万不要弄混了。"><a href="#注意：-gt-意思是创建，-gt-gt-是追加。千万不要弄混了。" class="headerlink" title="注意：&gt;意思是创建，&gt;&gt;是追加。千万不要弄混了。"></a>注意：&gt;意思是创建，&gt;&gt;是追加。千万不要弄混了。</h2><p>tac (反向列示)<br>tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，</p><h2 id="而-tac-则是由最后一行到第一行反向在萤幕上显示出来！"><a href="#而-tac-则是由最后一行到第一行反向在萤幕上显示出来！" class="headerlink" title="而 tac 则是由最后一行到第一行反向在萤幕上显示出来！"></a>而 tac 则是由最后一行到第一行反向在萤幕上显示出来！</h2><p>在Linux中echo命令用来在标准输出上显示一段字符，比如：<br>echo “the echo command test!”<br>这个就会输出“the echo command test!”这一行文字！<br>echo “the echo command test!”&gt;a.sh<br>这个就会在a.sh文件中输出“the echo command test!”这一行文字！<br>该命令的一般格式为： echo [ -n ] 字符串其中选项n表示输出文字后不换行；字符串能加引号，也能不加引号。<br>用echo命令输出加引号的字符串时，将字符串原样输出；<br>用echo命令输出不加引号的字符串时，将字符串中的各个单词作为字符串输出，各字符串之间用一个空格分割。</p><h3 id="退出命令"><a href="#退出命令" class="headerlink" title="退出命令"></a>退出命令</h3><p>q<br>ctrl c</p><h3 id="XShell5工具"><a href="#XShell5工具" class="headerlink" title="XShell5工具"></a>XShell5工具</h3><p>上传文件到linux<br>-b 以二进制方式，默认为文本方式。<br>-e 对所有控制字符转义。<br>如果要保证上传的文件内容在服务器端保存之后与原始文件一致，最好同时设置这两个标志，如下所示方式使用：<br>rz –bey</p><p>下载一个文件<br>sz filename<br>下载多个文件<br>sz filename1 filename2<br>下载dir目录下的文件，不包括文件夹<br>sz dir/*</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 18 2018 10:49:06 GMT+0800 (CST) --&gt;&lt;h3 id=&quot;Linux路径&quot;&gt;&lt;a href=&quot;#Linux路径&quot; class=&quot;headerlink&quot; title=&quot;Linux路径&quot;&gt;&lt;/a&gt;Linux路
      
    
    </summary>
    
      <category term="linux" scheme="https://rexlinbin.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://rexlinbin.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常处理</title>
    <link href="https://rexlinbin.github.io/2018/07/06/java-throwable/"/>
    <id>https://rexlinbin.github.io/2018/07/06/java-throwable/</id>
    <published>2018-07-06T06:01:24.000Z</published>
    <updated>2018-07-16T08:35:16.428Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 18 2018 10:49:06 GMT+0800 (CST) --><h2 id="Java异常类层次结构图"><a href="#Java异常类层次结构图" class="headerlink" title="Java异常类层次结构图"></a>Java异常类层次结构图</h2><p><img src="https://images2015.cnblogs.com/blog/641003/201607/641003-20160706232044280-355354790.png" alt="java异常类层次结构图"></p><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>异常的英文单词是exception，字面翻译就是“意外、例外”的意思，也就是非正常情况。事实上，异常本质上是程序上的错误，包括程序逻辑错误和系统错误。比如使用空的引用、数组下标越界、内存溢出错误等，这些都是意外的情况，背离我们程序本身的意图。错误在我们编写程序的过程中会经常发生，包括编译期间和运行期间的错误，在编译期间出现的错误有编译器帮助我们一起修正，然而运行期间的错误便不是编译器力所能及了，并且运行期间的错误往往是难以预料的。假若程序在运行期间出现了错误，如果置之不理，程序便会终止或直接导致系统崩溃，显然这不是我们希望看到的结果。因此，如何对运行期间出现的错误进行处理和补救呢？Java提供了异常机制来进行处理，通过异常机制来处理程序运行期间出现的错误。通过异常机制，我们可以更好地提升程序的健壮性。</p><h3 id="unchecked-exception（非检查异常）"><a href="#unchecked-exception（非检查异常）" class="headerlink" title="unchecked exception（非检查异常）"></a>unchecked exception（非检查异常）</h3><p>也称运行时异常（RuntimeException），比如常见的NullPointerException、IndexOutOfBoundsException。对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。</p><h3 id="checked-exception（检查异常，编译异常）"><a href="#checked-exception（检查异常，编译异常）" class="headerlink" title="checked exception（检查异常，编译异常）"></a>checked exception（检查异常，编译异常）</h3><p>也称非运行时异常（运行时异常以外的异常就是非运行时异常），java编译器强制程序员必须进行捕获处理，比如常见的IOExeption和SQLException。对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</p><h2 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h2><p>有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p><h3 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h3><p>是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java中，错误通过Error的子类描述。</p><h3 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h3><p>是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（NullPointerException、ArithmeticException）和 ArrayIndexOutOfBoundException。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。<br>可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。<br>除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。</p><h3 id="应该catch什么"><a href="#应该catch什么" class="headerlink" title="应该catch什么"></a>应该catch什么</h3><p>其实只要是Throwable和其子类都是可以throw和catch的，那么如果在需要统一处理异常的地方，我们应该catch (Throwable th) 还是 catch (Exception)呢？<br>这两种处理的区别在于，catch throwable会把Error和其他继承Throwable的类捕捉到。而catch Exception只会捕捉Exception极其子类，捕捉的范围更小。先不考虑有其他的类继承了Throwable的情况下，第一种catch相当于比第二种catch多捕捉了把Error和其子类。<br>那么究竟Error是否需要捕捉呢？JDK中Error类的的注释（如下）里提到过，Error是一种严重的问题，应用程序不应该捕捉它。<br>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. The ThreadDeath error, though a “normal” condition, is also a subclass of Error because most applications should not try to catch it.<br>A method is not required to declare in its throws clause any subclasses of Error that might be thrown during the execution of the method but not caught, since these errors are abnormal conditions that should never occur.<br>Java Lanuage Spec 7 中也提到：Error继承自Throwable而不是继承自Exception，是为了方便程序可以使用 “catch (Exception)“来捕捉异常而不会把Error也捕捉在内，因为Exception发生后可以进行一些恢复工作的，但是Error发生后一般是不可恢复的。<br>The class Error is a separate subclass ofThrowable, distinct from Exception in the class<br>hierarchy, to allow programs to use the idiom “} catch (Exception e) { ” (§11.2.3)<br>to catch all exceptions from which recovery may be possible without catching errors from which recovery is typically not possible.<br>已经不难看出，Java本身设计思路就是希望大家catch Exception就足够了，如果有Error发生，catch了也不会有什么作用。</p><h3 id="Error可以catch吗？-可以catch了后做些其他处理吗？"><a href="#Error可以catch吗？-可以catch了后做些其他处理吗？" class="headerlink" title="Error可以catch吗？ 可以catch了后做些其他处理吗？"></a>Error可以catch吗？ 可以catch了后做些其他处理吗？</h3><p>Error是可以catch的，而且也可以向常规Exception一样被处理，而且就算不捕捉的话也只是导致当前线程挂掉，其他线程还是可以正常运行，如果有需要的话捕捉Error之后也可以做些其他处理。但是Error是一种系统内部的错误，这种错误不像Exception一样是可能是程序和业务上的错误是可以恢复的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 18 2018 10:49:06 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;Java异常类层次结构图&quot;&gt;&lt;a href=&quot;#Java异常类层次结构图&quot; class=&quot;headerlink&quot; title=&quot;Java异常类层次
      
    
    </summary>
    
      <category term="java" scheme="https://rexlinbin.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://rexlinbin.github.io/tags/java/"/>
    
      <category term="exception" scheme="https://rexlinbin.github.io/tags/exception/"/>
    
      <category term="throwable" scheme="https://rexlinbin.github.io/tags/throwable/"/>
    
  </entry>
  
  <entry>
    <title>Android Mac 环境配置</title>
    <link href="https://rexlinbin.github.io/2018/07/04/android-mac/"/>
    <id>https://rexlinbin.github.io/2018/07/04/android-mac/</id>
    <published>2018-07-04T09:16:11.000Z</published>
    <updated>2018-07-06T07:59:55.786Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 18 2018 10:49:06 GMT+0800 (CST) --><h2 id="Java环境"><a href="#Java环境" class="headerlink" title="Java环境"></a>Java环境</h2><p>1）下载安装</p><p>mac系统一般默认会安装jdk 1.6,路径为/System/Library/Java/JavaVirtualMachines/1.6.0.jdk,但有时候可能需要下载更高版本的jdk</p><p>官网下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>2）配置</p><p>配置方式为 vim ~/.bash_profile,增加或修改</p><p>export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</p><p>export JAVA_HOME</p><p>export PATH=$PATH:$JAVA_HOME</p><p>最后重新加载profile</p><p>source ~/.bash_profile</p><p>3）验证</p><p>java -version</p><p>可以查看到当前版本信息代表安装配置成功。</p><h2 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h2><p>1） 下载安装</p><p>官网下载：<a href="http://developer.android.com/tools/studio/index.html" target="_blank" rel="noopener">http://developer.android.com/tools/studio/index.html</a></p><p>得到的dmg文件直接拖到Applications安装，注意安装路径</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 18 2018 10:49:06 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;Java环境&quot;&gt;&lt;a href=&quot;#Java环境&quot; class=&quot;headerlink&quot; title=&quot;Java环境&quot;&gt;&lt;/a&gt;Java环境&lt;/h
      
    
    </summary>
    
      <category term="android" scheme="https://rexlinbin.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://rexlinbin.github.io/tags/android/"/>
    
      <category term="mac" scheme="https://rexlinbin.github.io/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>冷月当空，雪魂飞舞</title>
    <link href="https://rexlinbin.github.io/2018/07/04/hello-world/"/>
    <id>https://rexlinbin.github.io/2018/07/04/hello-world/</id>
    <published>2018-07-04T08:58:08.061Z</published>
    <updated>2018-07-04T08:58:08.061Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Jul 18 2018 10:49:06 GMT+0800 (CST) --><p>欢迎来到冷月阁</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="这是一个小小的博客"><a href="#这是一个小小的博客" class="headerlink" title="这是一个小小的博客"></a>这是一个小小的博客</h3><p>进行必要的知识储备，现如今是信息时代，知识更新迅速，需要不断学习，才能保证不被时代丢弃，我是一个程序员，所以这里会是我各种技术文档的存放地，当然也可能会存放其他文章，视情况而定，所以出现其他类文章，大家不要惊讶，哈哈。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Jul 18 2018 10:49:06 GMT+0800 (CST) --&gt;&lt;p&gt;欢迎来到冷月阁&lt;/p&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
